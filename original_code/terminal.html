<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>BTC Quant Terminal V27 | Pro Strategy Suite</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Lightweight Charts -->
    <script src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>

    <!-- FontAwesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <!-- Fonts -->
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;700&display=swap"
        rel="stylesheet">

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        bg: '#0b0e11', panel: '#151a23', border: '#242b3b', text: '#94a3b8',
                        white: '#e2e8f0', accent: '#2962ff', bull: '#089981', bear: '#f23645',
                        fvg: '#a855f7', ob: '#eab308', trend: '#e879f9', reg: '#3b82f6', strat: '#f59e0b',
                        pending: '#64748b'
                    },
                    fontFamily: { sans: ['Inter', 'sans-serif'], mono: ['JetBrains Mono', 'monospace'] }
                }
            }
        }
    </script>

    <style>
        body {
            background-color: #0b0e11;
            color: #94a3b8;
            overflow: hidden;
        }

        ::-webkit-scrollbar {
            width: 5px;
            height: 5px;
        }

        ::-webkit-scrollbar-track {
            background: #0b0e11;
        }

        ::-webkit-scrollbar-thumb {
            background: #242b3b;
            border-radius: 3px;
        }

        #tv-chart {
            width: 100%;
            height: 100%;
        }

        .tf-btn {
            background: transparent;
            color: #64748b;
            border: 1px solid #242b3b;
            transition: 0.2s;
        }

        .tf-btn:hover {
            border-color: #2962ff;
            color: white;
        }

        .tf-btn.active {
            background-color: #2962ff;
            color: white;
            border-color: #2962ff;
            box-shadow: 0 0 10px rgba(41, 98, 255, 0.3);
        }

        .main-tab.active {
            color: #e2e8f0;
            border-bottom: 2px solid #2962ff;
            background: linear-gradient(180deg, rgba(41, 98, 255, 0) 0%, rgba(41, 98, 255, 0.1) 100%);
        }

        .main-tab {
            color: #64748b;
            border-bottom: 2px solid transparent;
            transition: 0.2s;
        }

        .sub-tab {
            @apply text-[10px] font-bold py-1.5 rounded border border-transparent text-slate-500 transition-colors;
        }

        .sub-tab:hover {
            @apply text-slate-300 bg-white/5;
        }

        .sub-tab.active {
            @apply bg-accent text-white border-accent shadow-sm;
        }

        .hidden-panel {
            display: none;
        }

        input[type=range] {
            -webkit-appearance: none;
            background: transparent;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 10px;
            width: 10px;
            border-radius: 50%;
            background: #2962ff;
            margin-top: -3px;
            cursor: pointer;
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            background: #242b3b;
            border-radius: 2px;
        }

        .spinner {
            border: 2px solid rgba(41, 98, 255, 0.1);
            border-left-color: #2962ff;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .metric-card {
            @apply bg-[#1e232e] p-3 rounded border border-border flex flex-col items-center justify-center;
        }

        .metric-label {
            @apply text-[9px] text-slate-500 font-bold uppercase tracking-wider mb-1;
        }

        .metric-value {
            @apply text-sm font-mono font-bold text-white;
        }

        .custom-scroll::-webkit-scrollbar {
            width: 4px;
        }

        .custom-scroll::-webkit-scrollbar-thumb {
            background: #334155;
            border-radius: 2px;
        }

        .input-dark {
            @apply bg-[#0b0e11] border border-border rounded px-2 py-1 text-xs text-white font-mono focus:border-accent focus:outline-none w-full;
        }

        .strat-card {
            transition: all 0.2s ease;
        }
    </style>
</head>

<body class="flex h-screen overflow-hidden font-sans text-sm selection:bg-accent selection:text-white">

    <!-- Sidebar -->
    <aside class="w-14 flex-shrink-0 border-r border-border bg-[#0f1218] flex flex-col items-center py-4 z-50">
        <div class="text-white text-lg font-bold mb-6"><i class="fa-brands fa-bitcoin text-[#f7931a]"></i></div>
        <div class="flex flex-col gap-2 w-full items-center px-2">
            <button onclick="setTF('1m')" id="btn-tf-1m"
                class="tf-btn w-full h-8 rounded text-[10px] font-bold">1m</button>
            <button onclick="setTF('5m')" id="btn-tf-5m"
                class="tf-btn w-full h-8 rounded text-[10px] font-bold">5m</button>
            <button onclick="setTF('15m')" id="btn-tf-15m"
                class="tf-btn w-full h-8 rounded text-[10px] font-bold active">15m</button>
            <button onclick="setTF('1h')" id="btn-tf-1h"
                class="tf-btn w-full h-8 rounded text-[10px] font-bold">1H</button>
            <button onclick="setTF('4h')" id="btn-tf-4h"
                class="tf-btn w-full h-8 rounded text-[10px] font-bold">4H</button>
        </div>
    </aside>

    <!-- Main -->
    <main class="flex-1 flex flex-col overflow-hidden relative bg-bg">
        <!-- Header -->
        <header
            class="bg-panel/90 backdrop-blur border-b border-border px-4 py-2 flex justify-between items-center shrink-0 h-12">
            <div class="flex items-center gap-4">
                <h1 class="text-white font-bold text-sm tracking-wide">BTC/USDT <span id="header-tf"
                        class="text-xs text-slate-500 ml-2 border border-border px-1 rounded">15m</span></h1>
                <div class="h-4 w-px bg-border"></div>
                <span id="live-price" class="font-mono font-bold text-lg text-white">---</span>
                <span id="ws-status" class="text-[10px] text-slate-500 flex items-center gap-1">
                    <div class="w-2 h-2 rounded-full bg-slate-700" id="ws-dot"></div> <span
                        id="ws-text">Desconectado</span>
                </span>
            </div>
            <div class="flex items-center gap-3">
                <div id="loading-msg" class="hidden flex items-center gap-2 text-[10px] text-accent font-mono">
                    <div class="spinner"></div> Cargando historial...
                </div>
                <div id="mode-indicator"
                    class="text-[10px] font-bold px-2 py-1 rounded bg-panel border border-border text-accent uppercase">
                    Modo: Zonas</div>
                <button id="btn-back-live" onclick="exitReplay()"
                    class="hidden flex items-center gap-2 px-3 py-1 rounded bg-accent hover:bg-blue-600 text-white text-[10px] font-bold transition shadow-lg shadow-blue-900/20 animate-pulse">
                    <i class="fa-solid fa-xmark"></i> Cerrar Vista
                </button>
                <button onclick="manualRefresh()" class="text-white hover:text-accent transition"><i
                        class="fa-solid fa-sync"></i></button>
            </div>
        </header>

        <!-- Grid -->
        <div class="flex-1 grid grid-cols-1 lg:grid-cols-4 gap-0 overflow-hidden">

            <!-- CHART -->
            <div class="lg:col-span-3 relative flex flex-col border-r border-border bg-[#0b0e11]">
                <div id="chart-loader" class="absolute inset-0 z-50 bg-[#0b0e11] flex items-center justify-center">
                    <span class="text-[10px] font-mono text-accent animate-pulse">Iniciando Terminal V27 Pro...</span>
                </div>
                <div id="tv-chart"></div>
            </div>

            <!-- RIGHT PANEL -->
            <div class="lg:col-span-1 bg-[#131620] flex flex-col overflow-hidden">

                <!-- Main Tabs -->
                <div class="flex border-b border-border bg-[#11141b] flex-shrink-0 overflow-x-auto">
                    <button onclick="switchMainTab('zones')" id="mtab-zones"
                        class="main-tab active min-w-[50px] flex-1 py-3 text-[10px] font-bold uppercase flex flex-col items-center gap-1"><i
                            class="fa-solid fa-layer-group"></i> SMC</button>
                    <button onclick="switchMainTab('trades')" id="mtab-trades"
                        class="main-tab min-w-[50px] flex-1 py-3 text-[10px] font-bold uppercase flex flex-col items-center gap-1"><i
                            class="fa-solid fa-crosshairs"></i> Op</button>
                    <button onclick="switchMainTab('lines')" id="mtab-lines"
                        class="main-tab min-w-[50px] flex-1 py-3 text-[10px] font-bold uppercase flex flex-col items-center gap-1"><i
                            class="fa-solid fa-chart-line"></i> TL</button>
                    <button onclick="switchMainTab('strat')" id="mtab-strat"
                        class="main-tab min-w-[50px] flex-1 py-3 text-[10px] font-bold uppercase flex flex-col items-center gap-1"><i
                            class="fa-solid fa-chess-knight"></i> EST</button>
                    <button onclick="switchMainTab('pnl')" id="mtab-pnl"
                        class="main-tab min-w-[50px] flex-1 py-3 text-[10px] font-bold uppercase flex flex-col items-center gap-1"><i
                            class="fa-solid fa-chart-pie"></i> PnL</button>
                </div>

                <!-- Content Container -->
                <div class="flex-1 overflow-hidden relative bg-[#0f1218]">

                    <!-- VISTA 1: ZONAS -->
                    <div id="view-zones" class="absolute inset-0 flex flex-col">
                        <div class="p-4 border-b border-border bg-[#161b25]">
                            <div class="flex justify-between mb-2"><span
                                    class="text-[10px] font-bold text-slate-400">Scanner SMC (Filtros Activos)</span>
                            </div>
                            <div class="flex justify-center gap-3 mb-3">
                                <label class="flex items-center gap-1 text-[10px] cursor-pointer"><input type="checkbox"
                                        id="toggle-fvg" checked onchange="updateVisuals()"> <span
                                        class="text-fvg font-bold">FVG</span></label>
                                <label class="flex items-center gap-1 text-[10px] cursor-pointer"><input type="checkbox"
                                        id="toggle-ob" checked onchange="updateVisuals()"> <span
                                        class="text-ob font-bold">OB</span></label>
                            </div>
                            <div class="flex items-center gap-2"><label
                                    class="text-[9px] text-slate-500">Profundidad:</label><input type="range"
                                    id="zone-limit" min="5" max="200" value="50" class="w-full h-1 bg-border rounded-lg"
                                    oninput="updateVisuals()"><span id="zone-count-display"
                                    class="text-[9px] text-white font-mono">50</span></div>
                            <div class="mt-2 text-[9px] text-slate-600 flex justify-between">
                                <span><i class="fa-solid fa-bolt text-accent"></i> ATR Filter</span>
                                <span><i class="fa-solid fa-signal text-accent"></i> Vol Filter</span>
                                <span><i class="fa-solid fa-chart-bar text-accent"></i> BOS</span>
                            </div>
                        </div>
                        <div class="px-2 py-2 flex gap-1 border-b border-border bg-panel shrink-0">
                            <button onclick="switchZoneSubTab('active')" id="ztab-active"
                                class="sub-tab active flex-1">Activas (Live)</button>
                            <button onclick="switchZoneSubTab('history')" id="ztab-history"
                                class="sub-tab flex-1">Historial (Filled)</button>
                        </div>
                        <div class="flex-1 overflow-y-auto custom-scroll">
                            <div id="list-zones-active" class="divide-y divide-border">
                                <div class="p-4 text-center text-xs text-slate-600 italic">Cargando zonas...</div>
                            </div>
                            <div id="list-zones-history" class="hidden-panel divide-y divide-border">
                                <div class="p-4 text-center text-xs text-slate-600 italic">Sin historial disponible.
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- VISTA 2: TRADES (OPERACIONES) -->
                    <div id="view-trades" class="hidden-panel absolute inset-0 flex flex-col">
                        <!-- Selector de Estrategia para Operaciones -->
                        <div class="px-4 py-3 bg-[#161b25] border-b border-border flex items-center gap-2">
                            <label
                                class="text-[10px] text-slate-500 font-bold uppercase whitespace-nowrap">Estrategia:</label>
                            <select id="trade-strat-select"
                                class="bg-[#0b0e11] border border-border rounded text-[10px] text-white px-2 py-1 focus:outline-none focus:border-accent w-full"
                                onchange="updateTradeStrategy()">
                                <option value="SMC">SMC (Reversal Limits)</option>
                                <option value="TL_TRAP">TL Trap (2:1)</option>
                                <option value="TL_TRAP_AGRO">TL Trap Agro (3:1)</option>
                                <option value="TL_TRAP_ATR">TL Trap ATR (2:1)</option>
                                <option value="TL_TRAP_ATR_AGRO">TL Trap ATR Agro (3:1)</option>
                                <option value="TL_TRAP_ATR_PARTIAL_1">TL Trap Parcial (3R + 5R)</option>
                                <option value="TL_TRAP_ATR_PARTIAL_2">TL Trap Parcial (2R + 4R)</option>
                            </select>
                        </div>
                        <div class="px-2 py-2 flex gap-1 border-b border-border bg-panel shrink-0">
                            <button onclick="switchTradeSubTab('ideas')" id="ttab-ideas"
                                class="sub-tab active flex-1">Ideas</button>
                            <button onclick="switchTradeSubTab('active')" id="ttab-active"
                                class="sub-tab flex-1">Activas</button>
                            <button onclick="switchTradeSubTab('history')" id="ttab-history"
                                class="sub-tab flex-1">Historial</button>
                        </div>
                        <div class="flex-1 overflow-y-auto custom-scroll">
                            <div id="list-trades-ideas" class="divide-y divide-border">
                                <div class="p-4 text-center text-xs text-slate-600 italic">Buscando setups...</div>
                            </div>
                            <div id="list-trades-active" class="hidden-panel divide-y divide-border">
                                <div class="p-4 text-center text-xs text-slate-600 italic">Nada activo.</div>
                            </div>
                            <div id="list-trades-history" class="hidden-panel divide-y divide-border">
                                <div class="p-4 text-center text-xs text-slate-600 italic">Historial vacío.</div>
                            </div>
                        </div>
                    </div>

                    <!-- VISTA 3: LINEAS -->
                    <div id="view-lines"
                        class="hidden-panel absolute inset-0 flex flex-col p-4 overflow-y-auto custom-scroll">
                        <div
                            class="bg-[#1e232e] p-3 rounded border border-border mb-4 flex items-center justify-between">
                            <div>
                                <div class="text-[10px] text-slate-500 font-bold uppercase">Exponente Hurst</div>
                                <div id="hurst-val" class="text-lg font-mono font-bold text-white">---</div>
                            </div>
                            <div class="text-right">
                                <div class="text-[9px] text-slate-400">Régimen</div>
                                <div id="hurst-type" class="text-xs font-bold text-trend">---</div>
                            </div>
                        </div>
                        <div class="bg-[#161b25] p-4 rounded border border-border mb-4">
                            <h3 class="text-xs font-bold text-white mb-2 uppercase"><i
                                    class="fa-solid fa-draw-polygon text-trend mr-2"></i>Configuración</h3>
                            <div class="space-y-4">
                                <div>
                                    <div class="flex justify-between text-[10px] text-slate-400 mb-1"><span>Fuerza
                                            Fractal</span><span id="lbl-fractal">5</span></div><input type="range"
                                        id="fractal-strength" min="2" max="30" value="5"
                                        class="w-full h-1 bg-border rounded-lg cursor-pointer"
                                        oninput="updateTrendSettings()">
                                </div>
                                <div>
                                    <div class="flex justify-between text-[10px] text-slate-400 mb-1"><span>Filtro de
                                            Ángulo</span><label
                                            class="relative inline-flex items-center cursor-pointer"><input
                                                type="checkbox" id="angle-filter-active" class="sr-only peer" checked
                                                onchange="updateTrendSettings()">
                                            <div
                                                class="w-7 h-4 bg-border peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-3 after:w-3 after:transition-all peer-checked:bg-trend">
                                            </div>
                                        </label></div><input type="range" id="angle-max" min="1" max="100" value="50"
                                        class="w-full h-1 bg-border rounded-lg cursor-pointer"
                                        oninput="updateTrendSettings()">
                                </div>
                                <div>
                                    <div class="flex justify-between text-[10px] text-slate-400 mb-1"><span>Tolerancia
                                            (Wicks)</span><span id="lbl-tolerance">Estricto</span></div><input
                                        type="range" id="trend-tolerance" min="0" max="10" value="0"
                                        class="w-full h-1 bg-border rounded-lg cursor-pointer"
                                        oninput="updateTrendSettings()">
                                </div>
                                <div class="flex items-center justify-between"><span
                                        class="text-[10px] text-slate-400">Estricto (Mechas)</span><label
                                        class="relative inline-flex items-center cursor-pointer"><input type="checkbox"
                                            id="trend-strict" class="sr-only peer" checked
                                            onchange="updateTrendSettings()">
                                        <div
                                            class="w-9 h-5 bg-border peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-trend">
                                        </div>
                                    </label></div>
                                <div class="flex items-center justify-between"><span
                                        class="text-[10px] text-slate-400">Mostrar Historial (Rotos)</span><label
                                        class="relative inline-flex items-center cursor-pointer"><input type="checkbox"
                                            id="trend-history" class="sr-only peer" onchange="updateTrendSettings()">
                                        <div
                                            class="w-9 h-5 bg-border peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-slate-500">
                                        </div>
                                    </label></div>
                            </div>
                        </div>
                        <div class="text-center"><button onclick="calculateTrendLines()"
                                class="bg-trend/10 hover:bg-trend/20 text-trend border border-trend/50 px-4 py-2 rounded text-xs font-bold w-full transition"><i
                                    class="fa-solid fa-rotate mr-2"></i> Recalcular Líneas</button></div>
                        <div id="lines-stats" class="mt-4 text-[10px] text-center text-slate-600 font-mono">...</div>
                    </div>

                    <!-- VISTA 3: ESTRATEGIA -->
                    <div id="view-strat"
                        class="hidden-panel absolute inset-0 flex flex-col p-4 overflow-y-auto custom-scroll">
                        <div class="bg-[#161b25] p-4 rounded border border-border mb-4">
                            <h3 class="text-xs font-bold text-white mb-2 uppercase flex items-center gap-2"><i
                                    class="fa-solid fa-chess-knight text-strat"></i> Motor de Estrategias</h3>
                            <div class="mb-4">
                                <label class="text-[10px] text-slate-500 font-bold mb-1 block">SELECCIONAR
                                    LÓGICA</label>
                                <select id="strat-selector"
                                    class="w-full bg-[#0b0e11] border border-border rounded text-xs text-white p-2 focus:outline-none focus:border-strat"
                                    onchange="updateStratDesc()">
                                    <option value="SMC">SMC Reversal (Estándar)</option>
                                    <option value="TL_TRAP">TL Trap (2:1)</option>
                                    <option value="TL_TRAP_AGRO">TL Trap Agro (3:1)</option>
                                    <option value="TL_TRAP_ATR">TL Trap ATR (2:1)</option>
                                    <option value="TL_TRAP_ATR_AGRO">TL Trap ATR Agro (3:1)</option>
                                    <option value="TL_TRAP_ATR_PARTIAL_1">TL Trap ATR Parcial (3:1 + 5:1)</option>
                                    <option value="TL_TRAP_ATR_PARTIAL_2">TL Trap ATR Parcial (2:1 + 4:1)</option>
                                </select>
                            </div>

                            <!-- Nueva Opción: Análisis de Volumen -->
                            <div class="mb-4 pt-2 border-t border-border/50">
                                <label class="flex items-center gap-2 text-[10px] cursor-pointer">
                                    <input type="checkbox" id="check-volume-analysis" class="accent-strat">
                                    <span class="text-slate-400">Análisis de Absorción/Volumen</span>
                                </label>
                                <p class="text-[9px] text-slate-600 mt-1 ml-5">Filtra entradas por señales de volumen
                                    institucional (más lento)</p>
                            </div>

                            <p id="strat-desc"
                                class="text-[10px] text-slate-500 mb-4 text-justify min-h-[40px] leading-relaxed">
                                Estrategia basada en zonas de Oferta/Demanda (OB) y vacíos de liquidez (FVG). Entra en
                                mitigación.
                            </p>
                            <button onclick="runSelectedStrategy()"
                                class="bg-strat/10 hover:bg-strat/20 text-strat border border-strat/50 px-4 py-2 rounded text-xs font-bold w-full transition"><i
                                    class="fa-solid fa-play mr-2"></i> EJECUTAR BACKTEST</button>
                        </div>
                        <div class="px-2 py-2 flex gap-1 border-b border-border bg-panel shrink-0 mb-2">
                            <button class="sub-tab active flex-1">Resultados Backtest</button>
                        </div>
                        <div id="list-strat-trades" class="space-y-2 pb-10">
                            <div class="p-4 text-center text-xs text-slate-600 italic">Selecciona y ejecuta...</div>
                        </div>
                    </div>

                    <!-- VISTA 4: REG LINEAL -->
                    <div id="view-reglin"
                        class="hidden-panel absolute inset-0 flex flex-col p-4 overflow-y-auto custom-scroll">
                        <div class="bg-[#161b25] p-4 rounded border border-border mb-4">
                            <h3 class="text-xs font-bold text-white mb-2 uppercase"><i
                                    class="fa-solid fa-ruler-combined text-reg mr-2"></i>Regresión Lineal</h3>
                            <div class="space-y-4">
                                <div>
                                    <div class="flex justify-between text-[10px] text-slate-400 mb-1">
                                        <span>Periodo</span><span id="lbl-reg-period">200</span></div><input
                                        type="range" id="reg-period" min="50" max="1000" value="200" step="50"
                                        class="w-full h-1 bg-border rounded-lg cursor-pointer"
                                        oninput="updateRegSettings()">
                                </div>
                                <div>
                                    <div class="flex justify-between text-[10px] text-slate-400 mb-1">
                                        <span>Desviación</span><span id="lbl-reg-std">2.0</span></div><input
                                        type="range" id="reg-std" min="1" max="4" value="2" step="0.1"
                                        class="w-full h-1 bg-border rounded-lg cursor-pointer"
                                        oninput="updateRegSettings()">
                                </div>
                            </div>
                        </div>
                        <div class="bg-[#1e232e] p-3 rounded border border-border text-center">
                            <div class="text-[10px] text-slate-500">Pendiente Canal</div>
                            <div id="reg-slope" class="text-lg font-mono font-bold text-reg">---</div>
                        </div>
                    </div>

                    <!-- VISTA 5: PNL -->
                    <div id="view-pnl"
                        class="hidden-panel absolute inset-0 flex flex-col p-4 overflow-y-auto custom-scroll">
                        <div class="bg-[#161b25] p-4 rounded border border-border mb-4 space-y-4">
                            <!-- Balance Inicial -->
                            <div>
                                <label class="text-[10px] text-slate-500 font-bold mb-1 block uppercase">Balance
                                    Inicial</label>
                                <div class="flex gap-2">
                                    <input type="number" id="initial-balance" value="10000" class="input-dark"
                                        onchange="updatePnLMetrics()">
                                    <button onclick="updatePnLMetrics()"
                                        class="bg-accent hover:bg-blue-600 text-white px-3 rounded text-[10px] font-bold flex items-center justify-center"><i
                                            class="fa-solid fa-save"></i></button>
                                </div>
                            </div>

                            <!-- Comisiones -->
                            <div class="grid grid-cols-2 gap-4 pt-2 border-t border-border/50">
                                <div>
                                    <label class="text-[10px] text-slate-500 font-bold mb-1 block uppercase">Comisión
                                        Maker %</label>
                                    <input type="number" id="fee-maker" value="0.1" step="0.01" class="input-dark"
                                        onchange="updatePnLMetrics()">
                                </div>
                                <div>
                                    <label class="text-[10px] text-slate-500 font-bold mb-1 block uppercase">Comisión
                                        Taker %</label>
                                    <input type="number" id="fee-taker" value="0.1" step="0.01" class="input-dark"
                                        onchange="updatePnLMetrics()">
                                </div>
                            </div>

                            <!-- Checkbox Descontar Comisiones -->
                            <div class="flex items-center gap-2 py-1">
                                <input type="checkbox" id="include-fees" class="accent-accent cursor-pointer"
                                    onchange="updatePnLMetrics()">
                                <label for="include-fees"
                                    class="text-[10px] text-slate-400 cursor-pointer select-none font-medium">Descontar
                                    Comisiones del PnL</label>
                            </div>
                        </div>

                        <div class="grid grid-cols-2 gap-2 mb-4">
                            <div class="bg-[#161b25] p-3 rounded border border-border">
                                <div class="text-[10px] text-slate-500 uppercase font-bold">Balance</div>
                                <div id="balance-current" class="text-xl font-bold font-mono text-white">---</div>
                            </div>
                            <div class="bg-[#161b25] p-3 rounded border border-border">
                                <div class="text-[10px] text-slate-500 uppercase font-bold">Equity</div>
                                <div id="balance-equity" class="text-xl font-bold font-mono text-accent">---</div>
                            </div>
                        </div>
                        <div class="mb-4">
                            <div class="text-[10px] text-slate-500 uppercase font-bold mb-1">Curva</div>
                            <div id="pnl-chart"
                                class="w-full h-40 bg-[#0b0e11] border border-border rounded overflow-hidden relative">
                            </div>
                        </div>
                        <div class="grid grid-cols-2 gap-2 mb-4">
                            <div class="bg-[#161b25] p-3 rounded border border-border">
                                <div class="text-[10px] text-slate-500">Realizado</div>
                                <div id="pnl-realized" class="text-lg font-bold font-mono text-slate-400">0.00</div>
                            </div>
                            <div class="bg-[#161b25] p-3 rounded border border-border">
                                <div class="text-[10px] text-slate-500">No Realizado</div>
                                <div id="pnl-unrealized" class="text-lg font-bold font-mono text-slate-400">0.00</div>
                            </div>
                        </div>
                        <div class="grid grid-cols-2 gap-2">
                            <div class="metric-card"><span class="metric-label">PF</span><span id="metric-pf"
                                    class="metric-value">---</span></div>
                            <div class="metric-card"><span class="metric-label">Win%</span><span id="metric-wr"
                                    class="metric-value">---</span></div>
                            <div class="metric-card"><span class="metric-label">Sharpe</span><span id="metric-sharpe"
                                    class="metric-value">---</span></div>
                            <div class="metric-card"><span class="metric-label">Sortino</span><span id="metric-sortino"
                                    class="metric-value">---</span></div>
                            <div class="metric-card"><span class="metric-label">DD</span><span id="metric-dd"
                                    class="metric-value text-bear">---</span></div>
                            <div class="metric-card"><span class="metric-label">Trades</span><span
                                    id="metric-total-trades" class="metric-value text-slate-400">0</span></div>
                        </div>
                        <div class="grid grid-cols-2 gap-2 mt-2 pb-4">
                            <div class="metric-card col-span-2"><span class="metric-label">Actividad</span><span
                                    id="metric-active-time" class="metric-value text-[10px] text-slate-300">---</span>
                            </div>
                            <div class="metric-card"><span class="metric-label">Avg Dur</span><span
                                    id="metric-avg-duration" class="metric-value">---</span></div>
                            <div class="metric-card"><span class="metric-label">Max Dur</span><span
                                    id="metric-max-duration" class="metric-value">---</span></div>
                        </div>
                        <span id="metric-avg-win" class="hidden"></span><span id="metric-avg-loss"
                            class="hidden"></span>
                    </div>

                    <!-- VISTA 6: LOG -->
                    <div id="view-log"
                        class="hidden-panel p-3 font-mono text-[10px] text-slate-500 space-y-1 absolute inset-0 overflow-y-auto">
                        <div id="system-log">System initialized...</div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <script>
        // --- APP STATE ---
        const APP = { symbol: 'BTCUSDT', interval: '15m', historyTarget: 30000, limitPerReq: 1000, sensitivity: 0.0001, riskReward: 2 };
        let state = { candles: [], zones: [], trades: [], lines: [], channel: null, activeMode: 'zones', initialBalance: 10000, activeZoneTab: 'active', activeTradeTab: 'ideas', isReplayMode: false };

        // VARIABLES GLOBALES
        let chart, candleSeries, volumeSeries, deltaSeries, boxPrimitive, trendPrimitive, regPrimitive, tradeLines = [], pnlChart, pnlSeries, ws = null;

        // --- GLOBAL HELPERS ---
        function calculateZoneQuality(gap, atr, impulsePercent, gapPercent) {
            const atrScore = (gap / atr) * 10;
            const impulseScore = impulsePercent * 100;
            const gapScore = gapPercent * 1000;
            return atrScore + impulseScore + gapScore;
        }

        function createTrade(idx, type, entry, sl, time, candles) {
            let trade = { id: idx, type: type, status: 'PENDING', entry: entry, sl: sl, tp: 0, signalTime: time, pnlValue: 0, pnlPercent: 0, pnl: 0 };
            if (type === 'LONG') trade.tp = trade.entry + ((trade.entry - trade.sl) * APP.riskReward);
            else trade.tp = trade.entry - ((trade.entry - trade.sl) * APP.riskReward);

            processTradeLifecycle(trade, idx, candles);
            return trade.status !== 'CANCELLED' ? trade : null;
        }

        function processTradeLifecycle(trade, idx, candles) {
            for (let j = idx + 1; j < candles.length; j++) {
                const bar = candles[j];
                if (trade.status === 'PENDING') {
                    if (trade.type === 'LONG') {
                        if (bar.low <= trade.entry) { trade.status = 'OPEN'; trade.entryTime = bar.time; }
                        else if (bar.low <= trade.sl) trade.status = 'CANCELLED';
                    } else { // SHORT
                        if (bar.high >= trade.entry) { trade.status = 'OPEN'; trade.entryTime = bar.time; }
                        else if (bar.high >= trade.sl) trade.status = 'CANCELLED';
                    }
                }
                else if (trade.status === 'OPEN') {
                    if (trade.type === 'LONG') {
                        if (bar.low <= trade.sl) { trade.status = 'LOSS'; trade.exitTime = bar.time; trade.pnl = -1; trade.pnlPercent = -1; break; }
                        if (bar.high >= trade.tp) { trade.status = 'WIN'; trade.exitTime = bar.time; trade.pnl = APP.riskReward; trade.pnlPercent = APP.riskReward; break; }
                    } else { // SHORT
                        if (bar.high >= trade.sl) { trade.status = 'LOSS'; trade.exitTime = bar.time; trade.pnl = -1; trade.pnlPercent = -1; break; }
                        if (bar.low <= trade.tp) { trade.status = 'WIN'; trade.exitTime = bar.time; trade.pnl = APP.riskReward; trade.pnlPercent = APP.riskReward; break; }
                    }
                }
            }
            if (trade.status === 'OPEN') {
                const lastPrice = candles[candles.length - 1].close;
                let rMultiple = 0;
                if (trade.type === 'LONG') rMultiple = (lastPrice - trade.entry) / (trade.entry - trade.sl);
                else rMultiple = (trade.entry - lastPrice) / (trade.sl - trade.entry);
                trade.pnl = rMultiple; trade.pnlPercent = rMultiple;
            }
        }

        function updatePnLMetrics() {
            state.initialBalance = parseFloat(document.getElementById('initial-balance').value) || 10000;

            const makerFeePct = parseFloat(document.getElementById('fee-maker')?.value || 0.1) / 100;
            const takerFeePct = parseFloat(document.getElementById('fee-taker')?.value || 0.1) / 100;
            const useFees = document.getElementById('include-fees')?.checked || false;

            const riskPerTrade = state.initialBalance * 0.01;

            let realizedPnL = 0, unrealizedPnL = 0, wins = 0, losses = 0, grossProfit = 0, grossLoss = 0, totalTrades = 0;
            let returns = [], equityCurve = [], firstTradeTime = null, lastTradeTime = null, totalDuration = 0, maxDuration = 0, durationCount = 0;

            if (state.candles.length > 0) equityCurve.push({ time: state.candles[0].time, value: state.initialBalance });

            let currentEquity = state.initialBalance, maxPeak = state.initialBalance, maxDrawdown = 0;

            const closedTrades = state.trades.filter(t => t.status === 'WIN' || t.status === 'LOSS');
            closedTrades.sort((a, b) => a.exitTime - b.exitTime);

            state.trades.forEach(t => {
                if (t.status === 'WIN' || t.status === 'LOSS' || t.status === 'OPEN') {
                    if (t.entryTime) {
                        if (!firstTradeTime || t.entryTime < firstTradeTime) firstTradeTime = t.entryTime;
                        let tradeEnd = t.exitTime || state.candles[state.candles.length - 1].time;
                        if (!lastTradeTime || tradeEnd > lastTradeTime) lastTradeTime = tradeEnd;
                        let dur = tradeEnd - t.entryTime;
                        totalDuration += dur;
                        if (dur > maxDuration) maxDuration = dur;
                        durationCount++;
                    }
                    if (t.status === 'OPEN') {
                        unrealizedPnL += (t.pnlPercent * riskPerTrade);
                    }
                }
            });

            closedTrades.forEach(t => {
                let pnlVal = t.pnlPercent * riskPerTrade;

                if (useFees) {
                    const entryPrice = t.entry;
                    const slPrice = t.sl;
                    const distSL = Math.abs(entryPrice - slPrice);

                    if (distSL > 0) {
                        const positionSizeUnits = riskPerTrade / distSL;
                        const notionalEntry = positionSizeUnits * entryPrice;
                        const exitPrice = (t.status === 'WIN' && t.tp) ? t.tp : (t.sl || entryPrice);
                        const notionalExit = positionSizeUnits * exitPrice;

                        const feeEntry = notionalEntry * takerFeePct;
                        const feeExit = (t.status === 'WIN') ? notionalExit * makerFeePct : notionalExit * takerFeePct;

                        const totalFees = feeEntry + feeExit;
                        pnlVal -= totalFees;
                    }
                }

                realizedPnL += pnlVal;
                currentEquity += pnlVal;
                returns.push(pnlVal);

                if (pnlVal > 0) { wins++; grossProfit += pnlVal; }
                else { losses++; grossLoss += Math.abs(pnlVal); }

                totalTrades++;

                if (currentEquity > maxPeak) maxPeak = currentEquity;
                const dd = (maxPeak - currentEquity) / maxPeak;
                if (dd > maxDrawdown) maxDrawdown = dd;

                const lastPoint = equityCurve[equityCurve.length - 1];
                if (lastPoint && lastPoint.time === t.exitTime) {
                    lastPoint.value = currentEquity;
                } else {
                    equityCurve.push({ time: t.exitTime, value: currentEquity });
                }
            });

            if (pnlSeries) {
                pnlSeries.setData(equityCurve);
                if (document.getElementById('view-pnl').style.display !== 'none') pnlChart.timeScale().fitContent();
            }

            const balanceVal = state.initialBalance + realizedPnL;
            const equityVal = balanceVal + unrealizedPnL;

            const elBal = document.getElementById('balance-current');
            const elEq = document.getElementById('balance-equity');
            if (elBal) elBal.innerText = "$" + balanceVal.toFixed(2);
            if (elEq) elEq.innerText = "$" + equityVal.toFixed(2);

            document.getElementById('pnl-realized').innerText = realizedPnL.toFixed(2);
            document.getElementById('pnl-unrealized').innerText = unrealizedPnL.toFixed(2);

            const winRate = totalTrades > 0 ? (wins / totalTrades) * 100 : 0;
            const profitFactor = grossLoss > 0 ? (grossProfit / grossLoss) : (grossProfit > 0 ? 999 : 0);
            const meanReturn = returns.reduce((a, b) => a + b, 0) / (returns.length || 1);
            const stdDev = Math.sqrt(returns.map(x => Math.pow(x - meanReturn, 2)).reduce((a, b) => a + b, 0) / (returns.length || 1));
            const sharpe = stdDev > 0 ? meanReturn / stdDev : 0;
            const downsideReturns = returns.filter(x => x < 0);
            const stdDevDown = Math.sqrt(downsideReturns.map(x => Math.pow(x, 2)).reduce((a, b) => a + b, 0) / (downsideReturns.length || 1));
            const sortino = stdDevDown > 0 ? meanReturn / stdDevDown : 0;

            const fmtDuration = (sec) => { if (!sec) return "---"; const d = Math.floor(sec / 86400); const h = Math.floor((sec % 86400) / 3600); const m = Math.floor((sec % 3600) / 60); return d > 0 ? `${d}d ${h}h` : (h > 0 ? `${h}h ${m}m` : `${m}m`); };

            const fmtDate = (sec) => {
                if (!sec) return "---";
                const d = new Date(sec * 1000);
                const day = String(d.getDate()).padStart(2, '0');
                const month = String(d.getMonth() + 1).padStart(2, '0');
                const year = d.getFullYear();
                return `${day}-${month}-${year}`;
            };

            document.getElementById('metric-pf').innerText = profitFactor.toFixed(2);
            document.getElementById('metric-wr').innerText = winRate.toFixed(1) + "%";
            document.getElementById('metric-sharpe').innerText = sharpe.toFixed(2);
            document.getElementById('metric-sortino').innerText = sortino.toFixed(2);
            document.getElementById('metric-dd').innerText = "-" + (maxDrawdown * 100).toFixed(2) + "%";
            document.getElementById('metric-total-trades').innerText = totalTrades;
            document.getElementById('metric-active-time').innerText = `${fmtDate(firstTradeTime)} - ${fmtDate(lastTradeTime)}`;
            document.getElementById('metric-avg-duration').innerText = fmtDuration(durationCount > 0 ? totalDuration / durationCount : 0);
            document.getElementById('metric-max-duration').innerText = fmtDuration(maxDuration);
        }

        // --- HELPER: PnL con "lock" para backtest/optimizador ---
        function safeUpdatePnLMetrics() {
            if (state.pnlLocked) return;
            updatePnLMetrics();
        }
        window.safeUpdatePnLMetrics = safeUpdatePnLMetrics;

        function clearLines() { tradeLines.forEach(l => candleSeries.removePriceLine(l)); tradeLines = []; }
        function createLine(price, color, title) { tradeLines.push(candleSeries.createPriceLine({ price, color, title, lineStyle: 2, lineWidth: 1, axisLabelVisible: true })); }

        function renderList(id, data, fn) {
            const el = document.getElementById(id);
            if (!el) { return; }
            el.innerHTML = data.length === 0 ? '<div class="p-4 text-center text-xs text-slate-600 italic">Vacío</div>' : data.map(fn).join('');
        }
        function renderZoneCard(z) { const color = z.type === 'FVG' ? 'text-fvg' : 'text-ob'; const statusLabel = z.status === 'MITIGATED' ? '<span class="text-[9px] text-bull font-bold">FILLED</span>' : ''; return `<div class="p-3 border-b border-border hover:bg-[#1e293b] cursor-pointer flex justify-between items-center group" onclick="goToZone('${z.id}')"><div><span class="${color} font-bold text-[10px]">${z.type}</span> <span class="text-[9px] text-slate-500">${new Date(z.time * 1000).toLocaleTimeString()}</span></div><div class="text-right"><div class="text-white font-mono text-xs">$${z.top.toFixed(2)}</div>${statusLabel}</div></div>`; }
        function renderTradeCard(t) {
            let color = 'text-slate-400';
            if (t.status === 'PENDING') color = 'text-pending';
            if (t.status === 'OPEN') color = 'text-ob animate-pulse';
            if (t.status === 'WIN') color = 'text-bull';
            if (t.status === 'LOSS') color = 'text-bear';

            const pnlDisplay = (t.pnl !== undefined && t.pnl !== null)
                ? t.pnl.toFixed(2) + 'R'
                : '0.00R';

            const pnlClass = t.pnl > 0 ? 'text-bull'
                : t.pnl < 0 ? 'text-bear'
                    : 'text-slate-500';

            const typeColor = t.type === 'LONG' ? 'text-bull' : 'text-bear';

            const refTime = t.signalTime || t.entryTime || t.time || null;
            const timeLabel = refTime
                ? new Date(refTime * 1000).toLocaleTimeString()
                : '---';

            const clickHandler = t.desc
                ? `replayStratTrade('${t.id}')`
                : `replayTrade(${t.id})`;

            const descLine = t.desc
                ? `<div class="text-[9px] text-slate-500 mt-1 truncate">${t.desc}</div>`
                : '';

            return `
                <div class="p-3 border-b border-border hover:bg-[#1e293b] cursor-pointer"
                     onclick="${clickHandler}">
                    <div class="flex justify-between items-center mb-1">
                        <span class="text-[10px] ${typeColor} font-bold">${t.type}</span>
                        <span class="text-[9px] font-bold ${color}">${t.status}</span>
                    </div>
                    <div class="flex justify-between text-[10px] font-mono">
                        <span>E: $${t.entry.toFixed(0)}</span>
                        <span class="${pnlClass}">${pnlDisplay}</span>
                    </div>
                    <div class="text-[9px] text-slate-500 mt-1 flex justify-between">
                        <span>${timeLabel}</span>
                        <span>TP: $${t.tp.toFixed(0)}</span>
                    </div>
                    ${descLine}
                </div>`;
        }

        // --- RENDERERS ---
        class BoxRenderer {
            constructor() { this._data = null; }
            update(data) { this._data = data; }
            draw(target) {
                target.useBitmapCoordinateSpace(scope => {
                    if (!this._data || this._data.boxes.length === 0) return;
                    const ctx = scope.context;
                    const timeScale = this._data.timeScale;
                    const series = this._data.series;
                    const pixelRatio = scope.horizontalPixelRatio;

                    this._data.boxes.forEach(box => {
                        const x1 = timeScale.timeToCoordinate(box.time);
                        let x2;

                        if (box.endTime) {
                            x2 = timeScale.timeToCoordinate(box.endTime);
                            if (x2 !== null && x2 < 0 && (x1 === null || x1 < 0)) return;
                        } else {
                            x2 = scope.mediaSize.width;
                        }

                        if (x1 !== null && x1 > scope.mediaSize.width) return;

                        const effX1 = x1 ?? 0;
                        const effX2 = x2 ?? scope.mediaSize.width;

                        if (effX2 < 0 || effX1 > scope.mediaSize.width) return;

                        const y1 = series.priceToCoordinate(box.top);
                        const y2 = series.priceToCoordinate(box.bottom);
                        if (y1 === null || y2 === null) return;

                        ctx.fillStyle = box.status === 'MITIGATED'
                            ? box.color.replace('0.4)', '0.15)')
                            : box.color;

                        const startX = Math.max(0, effX1);
                        const endX = Math.min(scope.mediaSize.width, effX2);

                        const x = Math.round(startX * pixelRatio);
                        const y = Math.round(Math.min(y1, y2) * pixelRatio);
                        const w = Math.round((endX - startX) * pixelRatio);
                        const h = Math.round(Math.abs(y2 - y1) * pixelRatio);

                        if (w <= 0) return;

                        ctx.fillRect(x, y, w, h);

                        if (box.status === 'MITIGATED') {
                            ctx.strokeStyle = box.color.replace('0.4)', '0.5)');
                            ctx.lineWidth = 1 * pixelRatio;
                            ctx.strokeRect(x, y, w, h);
                        }
                    });
                });
            }
        }
        class BoxPrimitive { constructor() { this._renderer = new BoxRenderer(); this._boxes = []; } setData(boxes) { this._boxes = boxes; this._requestUpdate(); } attached({ chart, series, requestUpdate }) { this._chart = chart; this._series = series; this._requestUpdate = requestUpdate; } detached() { this._chart = null; this._series = null; } updateAllViews() { this._requestUpdate(); } paneViews() { return [{ renderer: () => ({ draw: (target) => { this._renderer.update({ boxes: this._boxes, timeScale: this._chart.timeScale(), series: this._series }); this._renderer.draw(target); } }) }]; } priceAxisViews() { return []; } timeAxisViews() { return []; } autoscaleInfo() { return null; } }

        class TrendLineRenderer {
            constructor() { this._data = null; }
            update(data) { this._data = data; }
            draw(target) {
                target.useBitmapCoordinateSpace(scope => {
                    if (!this._data || this._data.lines.length === 0) return;
                    const ctx = scope.context;
                    const timeScale = this._data.timeScale;
                    const series = this._data.series;
                    const pixelRatio = scope.horizontalPixelRatio;
                    ctx.lineCap = 'round';

                    this._data.lines.forEach(l => {
                        const x1Raw = timeScale.timeToCoordinate(l.t1);
                        const x2Raw = timeScale.timeToCoordinate(l.t2);
                        const y1 = series.priceToCoordinate(l.p1);
                        const y2 = series.priceToCoordinate(l.p2);

                        if ((x1Raw === null && x2Raw === null) || y1 === null || y2 === null) return;

                        let x1 = x1Raw;
                        let x2 = x2Raw;

                        if (x1 === null) x1 = 0;
                        if (x2 === null) x2 = scope.mediaSize.width;

                        ctx.beginPath();
                        if (l.status === 'BROKEN') {
                            let color = l.color;
                            if (color.startsWith('#')) color = l.color === '#f23645' ? 'rgba(242, 54, 69, 0.6)' : 'rgba(8, 153, 129, 0.6)';
                            ctx.strokeStyle = color;
                            ctx.lineWidth = 2 * pixelRatio;
                            ctx.setLineDash([6, 4]);
                        } else {
                            ctx.strokeStyle = l.color;
                            ctx.lineWidth = Math.min(4, Math.max(2, l.score / 4)) * pixelRatio;
                            ctx.setLineDash([]);
                        }

                        const drawX1 = x1 * pixelRatio;
                        const drawY1 = y1 * pixelRatio;
                        const drawX2 = x2 * pixelRatio;
                        const drawY2 = y2 * pixelRatio;

                        ctx.moveTo(drawX1, drawY1);
                        ctx.lineTo(drawX2, drawY2);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    });
                });
            }
        }
        class TrendLinePrimitive { constructor() { this._renderer = new TrendLineRenderer(); this._lines = []; } setData(lines) { this._lines = lines; this._requestUpdate(); } attached({ chart, series, requestUpdate }) { this._chart = chart; this._series = series; this._requestUpdate = requestUpdate; } detached() { this._chart = null; this._series = null; } updateAllViews() { this._requestUpdate(); } paneViews() { return [{ renderer: () => ({ draw: (target) => { this._renderer.update({ lines: this._lines, timeScale: this._chart.timeScale(), series: this._series }); this._renderer.draw(target); } }) }]; } priceAxisViews() { return []; } timeAxisViews() { return []; } autoscaleInfo() { return null; } }

        class LinearRegressionPrimitive { constructor() { this._renderer = new LinearRegressionRenderer(); this._channel = null; } setData(channel) { this._channel = channel; this._requestUpdate(); } attached({ chart, series, requestUpdate }) { this._chart = chart; this._series = series; this._requestUpdate = requestUpdate; } detached() { this._chart = null; this._series = null; } updateAllViews() { this._requestUpdate(); } paneViews() { return [{ renderer: () => ({ draw: (target) => { this._renderer.update({ channel: this._channel, timeScale: this._chart.timeScale(), series: this._series }); this._renderer.draw(target); } }) }]; } priceAxisViews() { return []; } timeAxisViews() { return []; } autoscaleInfo() { return null; } }
        class LinearRegressionRenderer { constructor() { this._data = null; } update(data) { this._data = data; } draw(target) { target.useBitmapCoordinateSpace(scope => { if (!this._data || !this._data.channel) return; const c = this._data.channel; const ctx = scope.context; const timeScale = this._data.timeScale; const series = this._data.series; const pixelRatio = scope.horizontalPixelRatio; const x1 = timeScale.timeToCoordinate(c.t1); const x2 = timeScale.timeToCoordinate(c.t2); if (x1 === null && x2 === null) return; const effX1 = (x1 !== null ? x1 : -10000) * pixelRatio; const effX2 = (x2 !== null ? x2 : scope.mediaSize.width + 10000) * pixelRatio; const yMid1 = series.priceToCoordinate(c.mid1); const yMid2 = series.priceToCoordinate(c.mid2); const yUp1 = series.priceToCoordinate(c.up1); const yUp2 = series.priceToCoordinate(c.up2); const yLow1 = series.priceToCoordinate(c.low1); const yLow2 = series.priceToCoordinate(c.low2); if (yMid1 === null || yMid2 === null) return; const pyMid1 = yMid1 * pixelRatio; const pyMid2 = yMid2 * pixelRatio; const pyUp1 = yUp1 * pixelRatio; const pyUp2 = yUp2 * pixelRatio; const pyLow1 = yLow1 * pixelRatio; const pyLow2 = yLow2 * pixelRatio; ctx.fillStyle = 'rgba(59, 130, 246, 0.1)'; ctx.beginPath(); ctx.moveTo(effX1, pyUp1); ctx.lineTo(effX2, pyUp2); ctx.lineTo(effX2, pyLow2); ctx.lineTo(effX1, pyLow1); ctx.closePath(); ctx.fill(); ctx.lineWidth = 1 * pixelRatio; ctx.strokeStyle = '#3b82f6'; ctx.beginPath(); ctx.moveTo(effX1, pyMid1); ctx.lineTo(effX2, pyMid2); ctx.stroke(); ctx.strokeStyle = 'rgba(59, 130, 246, 0.5)'; ctx.beginPath(); ctx.moveTo(effX1, pyUp1); ctx.lineTo(effX2, pyUp2); ctx.stroke(); ctx.strokeStyle = 'rgba(59, 130, 246, 0.5)'; ctx.beginPath(); ctx.moveTo(effX1, pyLow1); ctx.lineTo(effX2, pyLow2); ctx.stroke(); }); } }

        document.addEventListener('DOMContentLoaded', () => { initChart(); initPnLChart(); runFullLoadPipeline(); });

        function initChart() {
            chart = LightweightCharts.createChart(document.getElementById('tv-chart'), {
                layout: { background: { type: 'solid', color: '#0b0e11' }, textColor: '#94a3b8', fontFamily: 'JetBrains Mono' },
                grid: { vertLines: { color: '#151a23' }, horzLines: { color: '#151a23' } },
                crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
                timeScale: { borderColor: '#242b3b', timeVisible: true, secondsVisible: false },
                rightPriceScale: { borderColor: '#242b3b' }
            });

            candleSeries = chart.addCandlestickSeries({
                upColor: '#089981', downColor: '#f23645',
                borderDownColor: '#f23645', borderUpColor: '#089981',
                wickDownColor: '#f23645', wickUpColor: '#089981'
            });

            // Volumen base con opacidad baja
            volumeSeries = chart.addHistogramSeries({
                priceFormat: { type: 'volume' },
                priceScaleId: 'volume'
            });

            // Delta superpuesto (mismo scale que volumen)
            deltaSeries = chart.addHistogramSeries({
                priceFormat: { type: 'volume' },
                priceScaleId: 'volume'
            });

            chart.priceScale('volume').applyOptions({
                scaleMargins: { top: 0.8, bottom: 0 },
                borderVisible: false
            });

            boxPrimitive = new BoxPrimitive(); candleSeries.attachPrimitive(boxPrimitive);
            trendPrimitive = new TrendLinePrimitive(); candleSeries.attachPrimitive(trendPrimitive);
            regPrimitive = new LinearRegressionPrimitive(); candleSeries.attachPrimitive(regPrimitive);

            window.addEventListener('resize', () => chart.applyOptions({ width: document.getElementById('tv-chart').clientWidth, height: document.getElementById('tv-chart').clientHeight }));
        }

        function initPnLChart() { const container = document.getElementById('pnl-chart'); pnlChart = LightweightCharts.createChart(container, { layout: { background: { type: 'solid', color: '#0b0e11' }, textColor: '#94a3b8', fontFamily: 'JetBrains Mono', fontSize: 10 }, grid: { vertLines: { color: '#151a23' }, horzLines: { color: '#151a23' } }, timeScale: { borderColor: '#242b3b', timeVisible: true, secondsVisible: false }, rightPriceScale: { borderColor: '#242b3b', scaleMargins: { top: 0.1, bottom: 0.1 } }, handleScroll: { mouseWheel: false, pressedMouseMove: false }, handleScale: { axisPressedMouseMove: false, mouseWheel: false, pinch: false } }); pnlSeries = pnlChart.addAreaSeries({ lineColor: '#2962ff', topColor: 'rgba(41, 98, 255, 0.4)', bottomColor: 'rgba(41, 98, 255, 0.0)', lineWidth: 2 }); new ResizeObserver(entries => { if (entries.length && entries[0].target === container) pnlChart.applyOptions({ width: entries[0].contentRect.width, height: entries[0].contentRect.height }); }).observe(container); }

        function updateVolumeData() {
            if (!volumeSeries || !deltaSeries || state.candles.length === 0) return;

            // Volumen total con opacidad baja
            const volumeData = state.candles.map(c => ({
                time: c.time,
                value: c.volume,
                color: c.close >= c.open ? 'rgba(8, 153, 129, 0.25)' : 'rgba(242, 54, 69, 0.25)'
            }));

            // Delta superpuesto: valor absoluto, color según signo
            const deltaData = state.candles.map(c => {
                const delta = c.delta || 0;
                const absDelta = Math.abs(delta);
                const color = delta >= 0 ? 'rgba(34, 197, 94, 0.8)' : 'rgba(248, 113, 113, 0.8)';
                return {
                    time: c.time,
                    value: absDelta,
                    color: color
                };
            });

            volumeSeries.setData(volumeData);
            deltaSeries.setData(deltaData);
        }

        async function runFullLoadPipeline() {
            if (ws) ws.close();
            state.candles = [];
            candleSeries.setData([]);
            if (volumeSeries) volumeSeries.setData([]);
            if (deltaSeries) deltaSeries.setData([]);

            boxPrimitive.setData([]);
            trendPrimitive.setData([]);
            regPrimitive.setData(null);

            document.getElementById('chart-loader').style.display = 'flex';

            await loadHistoricalData();
            updateVolumeData();

            analyzeSMC();
            calculateTrendLines();
            calculateRegLin();
            renderVisuals();
            updateUI();

            safeUpdatePnLMetrics();

            startWebSocket();

            document.getElementById('chart-loader').style.display = 'none';
        }

        async function loadHistoricalData() {
            const loadingMsg = document.getElementById('loading-msg'); loadingMsg.classList.remove('hidden'); loadingMsg.classList.add('flex');
            let allCandles = [], currentEndTime = null, iterations = Math.ceil(APP.historyTarget / APP.limitPerReq);
            try {
                for (let i = 0; i < iterations; i++) {
                    loadingMsg.innerHTML = `<div class="spinner"></div> Lote ${i + 1}/${iterations}`;
                    const batch = await fetchKlinesBatch(currentEndTime);
                    if (batch.length === 0) break;
                    currentEndTime = (batch[0].time * 1000) - 1;
                    allCandles = [...batch, ...allCandles];
                    await new Promise(r => setTimeout(r, 200));
                }
            } catch (e) { console.error("Error historial", e); }
            allCandles.sort((a, b) => a.time - b.time);
            const uniqueCandles = [], times = new Set();
            allCandles.forEach(c => { if (!times.has(c.time)) { times.add(c.time); uniqueCandles.push(c); } });
            state.candles = uniqueCandles;
            candleSeries.setData(state.candles);

            if (state.candles.length > 0) {
                document.getElementById('live-price').innerText = "$" + state.candles[state.candles.length - 1].close.toFixed(2);
            }

            loadingMsg.classList.add('hidden'); loadingMsg.classList.remove('flex');
        }

        async function fetchKlinesBatch(endTime) {
            let url = `https://api.binance.com/api/v3/klines?symbol=${APP.symbol}&interval=${APP.interval}&limit=${APP.limitPerReq}`;
            if (endTime) url += `&endTime=${endTime}`;
            try {
                const res = await fetch(url);
                const data = await res.json();
                return data.map(c => ({
                    time: c[0] / 1000,
                    open: parseFloat(c[1]),
                    high: parseFloat(c[2]),
                    low: parseFloat(c[3]),
                    close: parseFloat(c[4]),
                    volume: parseFloat(c[5]),
                    buyVolume: parseFloat(c[9]),
                    sellVolume: parseFloat(c[5]) - parseFloat(c[9]),
                    delta: parseFloat(c[9]) - (parseFloat(c[5]) - parseFloat(c[9]))
                }));
            } catch (e) {
                console.warn("REST API error", e);
                return [];
            }
        }

        function startWebSocket() {
            ws = new WebSocket(`wss://stream.binance.com:9443/ws/${APP.symbol.toLowerCase()}@kline_${APP.interval}`);
            ws.onopen = () => { document.getElementById('ws-dot').className = "w-2 h-2 rounded-full bg-bull animate-pulse"; document.getElementById('ws-text').innerText = "En vivo"; };
            ws.onmessage = (event) => {
                const k = JSON.parse(event.data).k;

                const totalVol = parseFloat(k.v);
                const buyVol = parseFloat(k.V);
                const sellVol = totalVol - buyVol;
                const delta = buyVol - sellVol;

                const candle = {
                    time: k.t / 1000,
                    open: parseFloat(k.o),
                    high: parseFloat(k.h),
                    low: parseFloat(k.l),
                    close: parseFloat(k.c),
                    volume: totalVol,
                    buyVolume: buyVol,
                    sellVolume: sellVol,
                    delta: delta
                };

                const last = state.candles[state.candles.length - 1];
                if (last && candle.time < last.time) {
                    return;
                }

                if (last && candle.time === last.time) {
                    state.candles[state.candles.length - 1] = candle;
                } else {
                    state.candles.push(candle);
                    if (state.candles.length > APP.historyTarget + 1000) state.candles.shift();
                }

                candleSeries.update(candle);

                if (volumeSeries) {
                    volumeSeries.update({
                        time: candle.time,
                        value: candle.volume,
                        color: candle.close >= candle.open ? 'rgba(8, 153, 129, 0.25)' : 'rgba(242, 54, 69, 0.25)'
                    });
                }
                if (deltaSeries) {
                    const deltaVal = candle.delta || 0;
                    deltaSeries.update({
                        time: candle.time,
                        value: Math.abs(deltaVal),
                        color: deltaVal >= 0 ? 'rgba(34, 197, 94, 0.8)' : 'rgba(248, 113, 113, 0.8)'
                    });
                }

                document.getElementById('live-price').innerText = "$" + candle.close.toFixed(2);

                if (state.activeMode === 'zones') analyzeSMC();
                else if (state.activeMode === 'trades') {
                    const strat = document.getElementById('trade-strat-select').value;
                    if (strat === 'SMC') analyzeSMC();
                    else runLiquidityStrategy();
                }

                if (state.activeMode === 'lines') { calculateTrendLines(); calculateHurst(); }
                if (state.activeMode === 'reglin') calculateRegLin();
                if (!document.getElementById('btn-back-live').classList.contains('flex') && state.activeMode !== 'strat') {
                    renderVisuals();
                }
                updateUI();

                if (state.activeMode !== 'strat') {
                    safeUpdatePnLMetrics();
                }
            };
            ws.onclose = () => { document.getElementById('ws-dot').className = "w-2 h-2 rounded-full bg-bear"; document.getElementById('ws-text').innerText = "Desconectado"; };
        }

        function calculateHurst() { const c = state.candles; if (c.length < 200) { document.getElementById('hurst-val').innerText = "---"; return; } const slice = c.slice(-200).map(x => x.close); const logs = []; for (let i = 1; i < slice.length; i++) logs.push(Math.log(slice[i] / slice[i - 1])); const mean = logs.reduce((a, b) => a + b, 0) / logs.length; const std = Math.sqrt(logs.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / logs.length); const deviation = logs.map(x => x - mean); let cumDev = 0, maxCum = -Infinity, minCum = Infinity; for (let v of deviation) { cumDev += v; if (cumDev > maxCum) maxCum = cumDev; if (cumDev < minCum) minCum = cumDev; } const R = maxCum - minCum; const S = std; const RS = R / S; let hurst = Math.log(RS) / Math.log(logs.length); if (hurst > 1) hurst = 0.99; if (hurst < 0) hurst = 0.01; const elVal = document.getElementById('hurst-val'); const elType = document.getElementById('hurst-type'); elVal.innerText = hurst.toFixed(2); if (hurst > 0.55) { elType.innerText = "TENDENCIA (TRENDING)"; elType.className = "text-xs font-bold text-trend"; } else if (hurst < 0.45) { elType.innerText = "RANGO (MEAN REVERTING)"; elType.className = "text-xs font-bold text-reg"; } else { elType.innerText = "RUIDO (RANDOM WALK)"; elType.className = "text-xs font-bold text-slate-500"; } }
        function calculateRegLin() { const period = parseInt(document.getElementById('reg-period').value); const stdMult = parseFloat(document.getElementById('reg-std').value); document.getElementById('lbl-reg-period').innerText = period; document.getElementById('lbl-reg-std').innerText = stdMult; const c = state.candles; if (c.length < period) return; const slice = c.slice(-period); const n = slice.length; let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0; for (let i = 0; i < n; i++) { sumX += i; sumY += slice[i].close; sumXY += i * slice[i].close; sumXX += i * i; } const m = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX); const b = (sumY - m * sumX) / n; let sumSqErr = 0; for (let i = 0; i < n; i++) { const yPred = m * i + b; sumSqErr += Math.pow(slice[i].close - yPred, 2); } const stdDev = Math.sqrt(sumSqErr / n); const futureBars = 20; const t1 = slice[0].time; const t2 = c[c.length - 1].time + (futureBars * 60 * (APP.interval === '1m' ? 1 : APP.interval === '5m' ? 5 : 60)); const pStart = b; const pEnd = m * (n - 1 + futureBars) + b; state.channel = { t1: t1, t2: t2, mid1: pStart, mid2: pEnd, up1: pStart + (stdDev * stdMult), up2: pEnd + (stdDev * stdMult), low1: pStart - (stdDev * stdMult), low2: pEnd - (stdDev * stdMult) }; document.getElementById('reg-slope').innerText = (m > 0 ? "+" : "") + m.toFixed(4); if (state.activeMode === 'reglin') renderVisuals(); }
        window.updateRegSettings = () => calculateRegLin();

        function calculateTrendLines(returnOnly = false) {
            calculateHurst();
            const fractalStrength = parseInt(document.getElementById('fractal-strength').value);
            const strictMode = document.getElementById('trend-strict').checked;
            const showHistory = document.getElementById('trend-history').checked;
            const useAngleFilter = document.getElementById('angle-filter-active').checked;
            const angleMax = parseInt(document.getElementById('angle-max').value);
            const toleranceInput = document.getElementById('trend-tolerance').value;
            const tolerance = parseInt(toleranceInput) * 0.0005;

            document.getElementById('lbl-fractal').innerText = fractalStrength;
            document.getElementById('lbl-tolerance').innerText = parseInt(toleranceInput) === 0 ? "Estricto" : (tolerance * 100).toFixed(2) + "%";

            const c = state.candles;
            if (c.length < 100) return [];

            let highs = [], lows = [];

            // Detectar pivots con diferentes fuerzas
            const strengths = [fractalStrength, Math.max(2, fractalStrength - 2), fractalStrength + 3];

            strengths.forEach(strength => {
                for (let i = strength; i < c.length - strength; i++) {
                    let isHigh = true;
                    let isLow = true;

                    for (let j = 1; j <= strength; j++) {
                        if (c[i - j].high > c[i].high || c[i + j].high > c[i].high) isHigh = false;
                        if (c[i - j].low < c[i].low || c[i + j].low < c[i].low) isLow = false;
                    }

                    if (isHigh && !highs.find(h => h.index === i)) {
                        highs.push({ index: i, time: c[i].time, price: c[i].high, volume: c[i].volume || 0, strength: strength });
                    }
                    if (isLow && !lows.find(l => l.index === i)) {
                        lows.push({ index: i, time: c[i].time, price: c[i].low, volume: c[i].volume || 0, strength: strength });
                    }
                }
            });

            highs.sort((a, b) => a.index - b.index);
            lows.sort((a, b) => a.index - b.index);

            let candidates = [];

            const processCandidates = (pivots, type) => {
                for (let i = pivots.length - 1; i >= 1; i--) {
                    let pivotA = pivots[i];
                    for (let j = i - 1; j >= 0; j--) {
                        let pivotB = pivots[j];

                        let isDirectionValid = type === 'DOWN' ? (pivotB.price > pivotA.price) : (pivotB.price < pivotA.price);
                        if (!isDirectionValid) continue;

                        const slope = (pivotA.price - pivotB.price) / (pivotA.index - pivotB.index);
                        const slopeNorm = Math.abs(slope / pivotB.price) * 10000;

                        if (useAngleFilter && slopeNorm > angleMax * 2) continue;

                        // SIN TOLERANCIA A VIOLACIONES - modo estricto siempre
                        let validStrict = true;
                        for (let k = pivotB.index + 1; k < pivotA.index; k++) {
                            const theoPrice = pivotB.price + slope * (k - pivotB.index);
                            if (type === 'DOWN' && c[k].high > theoPrice * (1 + tolerance)) {
                                validStrict = false;
                                break;
                            }
                            if (type === 'UP' && c[k].low < theoPrice * (1 - tolerance)) {
                                validStrict = false;
                                break;
                            }
                        }
                        if (!validStrict) continue;

                        // Contar toques Y GUARDAR SUS ÍNDICES
                        let touches = 2;
                        let touchIndices = [pivotB.index, pivotA.index];
                        let touchVolume = (pivotA.volume || 0) + (pivotB.volume || 0);
                        const touchTolerance = 0.002;

                        for (let k = pivotB.index + 1; k < pivotA.index; k++) {
                            const theoPrice = pivotB.price + slope * (k - pivotB.index);
                            const bar = c[k];
                            let touchPrice = type === 'DOWN' ? bar.high : bar.low;
                            let diff = Math.abs(touchPrice - theoPrice) / theoPrice;

                            if (diff <= touchTolerance) {
                                touches++;
                                touchIndices.push(k);
                                touchVolume += bar.volume || 0;
                            }
                        }

                        // Buscar rotura
                        let breakIndex = -1;
                        for (let k = pivotA.index + 1; k < c.length; k++) {
                            const theoPrice = pivotB.price + slope * (k - pivotB.index);
                            if (type === 'DOWN' && c[k].high > theoPrice * (1 + tolerance * 0.5)) { breakIndex = k; break; }
                            if (type === 'UP' && c[k].low < theoPrice * (1 - tolerance * 0.5)) { breakIndex = k; break; }
                        }

                        // Duración = tiempo que fue respetada (hasta rotura o hasta ahora)
                        const endIdx = breakIndex !== -1 ? breakIndex : c.length - 1;
                        const duration = c[endIdx].time - c[pivotB.index].time;
                        const durationHours = duration / 3600;

                        // Score basado principalmente en duración y toques
                        const touchBonus = Math.max(0, (touches - 2)) * 15;
                        const durationBonus = durationHours * 2;
                        const score = touchBonus + durationBonus;

                        let lineObj = {
                            t1: pivotB.time,
                            p1: pivotB.price,
                            color: type === 'DOWN' ? '#f23645' : '#089981',
                            width: 2,
                            score: score,
                            type: type,
                            slope: slope,
                            startIdx: pivotB.index,
                            endPivotIdx: pivotA.index,
                            touches: touches,
                            touchIndices: touchIndices,
                            duration: durationHours,
                            slopeNorm: slopeNorm
                        };

                        if (breakIndex !== -1) {
                            if (showHistory || returnOnly) {
                                lineObj.status = 'BROKEN';
                                lineObj.t2 = c[breakIndex].time;
                                lineObj.p2 = pivotB.price + slope * (breakIndex - pivotB.index);
                                lineObj.breakIndex = breakIndex;
                                lineObj.endIdx = breakIndex;
                                candidates.push(lineObj);
                            }
                        } else {
                            lineObj.status = 'ACTIVE';
                            const lastIdx = c.length - 1;
                            lineObj.t2 = c[lastIdx].time;
                            lineObj.p2 = pivotB.price + slope * (lastIdx - pivotB.index);
                            lineObj.endIdx = lastIdx;
                            candidates.push(lineObj);
                        }
                    }
                }
            };

            processCandidates(highs, 'DOWN');
            processCandidates(lows, 'UP');

            // Ordenar por DURACIÓN (mayor primero)
            candidates.sort((a, b) => b.duration - a.duration);

            const activeLines = candidates.filter(l => l.status === 'ACTIVE');
            const brokenLines = candidates.filter(l => l.status === 'BROKEN');

            // Filtrar duplicados activos
            let filteredActive = [];
            for (let l of activeLines) {
                let dominated = false;
                for (let k of filteredActive) {
                    const priceL = l.p1 + l.slope * (c.length - l.startIdx);
                    const priceK = k.p1 + k.slope * (c.length - k.startIdx);
                    const priceDiff = Math.abs(priceL - priceK) / priceK;

                    if (l.type === k.type && priceDiff < 0.01) {
                        dominated = true;
                        break;
                    }
                }
                if (!dominated) filteredActive.push(l);
                if (filteredActive.length >= 20) break;
            }

            // Filtrar duplicados rotos
            let filteredBroken = [];
            if (showHistory || returnOnly) {
                for (let l of brokenLines) {
                    let dominated = false;
                    for (let k of filteredBroken) {
                        const pDiff = Math.abs(l.p2 - k.p2) / k.p2;
                        const tDiff = Math.abs(l.t2 - k.t2);

                        if (l.type === k.type && tDiff < 3600 && pDiff < 0.01) {
                            dominated = true;
                            break;
                        }
                    }
                    if (!dominated) filteredBroken.push(l);
                }
            }

            const result = [...filteredActive, ...filteredBroken];
            if (returnOnly) return result;

            state.lines = result;
            document.getElementById('lines-stats').innerText = `Líneas: ${state.lines.length} (${filteredActive.length} Activas, ${filteredBroken.length} Rotas)`;
            if (state.activeMode === 'lines') renderVisuals();

            return result;
        }
        window.updateTrendSettings = () => calculateTrendLines();

        function analyzeSMC(keepTrades = false) {
            state.zones = [];
            if (!keepTrades) state.trades = [];

            const c = state.candles;
            if (c.length < 50) return;
            const sens = APP.sensitivity;

            const startIndex = Math.max(20, c.length - APP.historyTarget);
            let localTrades = [];

            // --- ATR ---
            const atrPeriod = 14;
            let atrValues = [];
            for (let i = startIndex; i < c.length; i++) {
                if (i < atrPeriod) continue;
                let trSum = 0;
                for (let j = 0; j < atrPeriod; j++) {
                    const idx = i - j;
                    const high = c[idx].high;
                    const low = c[idx].low;
                    const prevClose = c[idx - 1].close;
                    const tr = Math.max(high - low, Math.abs(high - prevClose), Math.abs(low - prevClose));
                    trSum += tr;
                }
                atrValues[i] = trSum / atrPeriod;
            }

            // --- Volumen promedio móvil ---
            const volPeriod = 20;
            let avgVolumes = [];
            for (let i = volPeriod; i < c.length; i++) {
                let volSum = 0;
                for (let j = 0; j < volPeriod; j++) {
                    volSum += c[i - j].volume || 0;
                }
                avgVolumes[i] = volSum / volPeriod;
            }

            // --- Swing Highs/Lows para BOS ---
            const swingLookback = 10;
            let swingHighs = [];
            let swingLows = [];
            for (let i = swingLookback; i < c.length - swingLookback; i++) {
                let isSwingHigh = true;
                let isSwingLow = true;
                for (let j = 1; j <= swingLookback; j++) {
                    if (c[i - j].high > c[i].high || c[i + j].high > c[i].high) isSwingHigh = false;
                    if (c[i - j].low < c[i].low || c[i + j].low < c[i].low) isSwingLow = false;
                }
                if (isSwingHigh) swingHighs.push({ index: i, price: c[i].high });
                if (isSwingLow) swingLows.push({ index: i, price: c[i].low });
            }

            const getLastSwingHigh = (idx) => {
                for (let i = swingHighs.length - 1; i >= 0; i--) {
                    if (swingHighs[i].index < idx) return swingHighs[i];
                }
                return null;
            };
            const getLastSwingLow = (idx) => {
                for (let i = swingLows.length - 1; i >= 0; i--) {
                    if (swingLows[i].index < idx) return swingLows[i];
                }
                return null;
            };

            const processedOBs = new Set();

            const barTouchesZone = (bar, top, bottom) => {
                const zTop = Math.max(top, bottom);
                const zBottom = Math.min(top, bottom);
                return bar.low <= zTop && bar.high >= zBottom;
            };

            const calculateOBScore = (obCandle, idx, isBullish, atr, avgVol) => {
                let score = 0;

                const vol = obCandle.volume || 0;
                const volRatio = avgVol > 0 ? vol / avgVol : 1;
                if (volRatio > 2.0) score += 30;
                else if (volRatio > 1.5) score += 20;
                else if (volRatio > 1.2) score += 10;

                const obSize = obCandle.high - obCandle.low;
                const sizeRatio = atr > 0 ? obSize / atr : 1;
                if (sizeRatio > 1.5) score += 25;
                else if (sizeRatio > 1.0) score += 15;
                else if (sizeRatio > 0.7) score += 8;

                if (isBullish) {
                    const lastSwingHigh = getLastSwingHigh(idx);
                    if (lastSwingHigh) {
                        for (let k = idx + 1; k < Math.min(idx + 20, c.length); k++) {
                            if (c[k].high > lastSwingHigh.price) {
                                score += 35;
                                break;
                            }
                        }
                    }
                } else {
                    const lastSwingLow = getLastSwingLow(idx);
                    if (lastSwingLow) {
                        for (let k = idx + 1; k < Math.min(idx + 20, c.length); k++) {
                            if (c[k].low < lastSwingLow.price) {
                                score += 35;
                                break;
                            }
                        }
                    }
                }

                if (idx > 0) {
                    const prev = c[idx - 1];
                    const isEngulfing = obCandle.high > prev.high && obCandle.low < prev.low;
                    if (isEngulfing) score += 15;
                }

                const midPrice = (obCandle.high + obCandle.low) / 2;
                const roundLevel = Math.round(midPrice / 1000) * 1000;
                const distToRound = Math.abs(midPrice - roundLevel) / midPrice;
                if (distToRound < 0.005) score += 20;
                else if (distToRound < 0.01) score += 10;

                return score;
            };

            const calculateFVGScore = (gap, impulsePercent, atr, avgVol, velas) => {
                let score = 0;

                const gapRatio = atr > 0 ? gap / atr : 0;
                if (gapRatio > 1.0) score += 30;
                else if (gapRatio > 0.7) score += 20;
                else if (gapRatio > 0.5) score += 12;
                else if (gapRatio > 0.3) score += 5;

                if (impulsePercent > 0.015) score += 25;
                else if (impulsePercent > 0.01) score += 18;
                else if (impulsePercent > 0.005) score += 10;

                const totalVol = velas.reduce((sum, v) => sum + (v.volume || 0), 0);
                const avgImpulseVol = totalVol / 3;
                const volRatio = avgVol > 0 ? avgImpulseVol / avgVol : 1;
                if (volRatio > 2.0) score += 25;
                else if (volRatio > 1.5) score += 15;
                else if (volRatio > 1.2) score += 8;

                return score;
            };

            for (let i = startIndex; i < c.length; i++) {
                const curr = c[i];
                const prev1 = c[i - 1];
                const prev2 = c[i - 2];
                const atr = atrValues[i] || (curr.high - curr.low);
                const avgVol = avgVolumes[i] || 1;

                // --- FVG Bullish ---
                if (curr.low > prev2.high) {
                    const gap = curr.low - prev2.high;
                    const gapPercent = gap / curr.close;
                    let validFVG = true;

                    if (gap < (curr.close * sens)) validFVG = false;
                    if (gap < atr * 0.2) validFVG = false;

                    const impulse = curr.close - prev2.close;
                    const impulsePercent = Math.abs(impulse / prev2.close);
                    if (impulsePercent < 0.003) validFVG = false;

                    if (curr.volume && prev1.volume && prev2.volume) {
                        const avgVolLocal = (prev1.volume + prev2.volume) / 2;
                        if (curr.volume < avgVolLocal * 0.5) validFVG = false;
                    }

                    if (validFVG) {
                        const fvgScore = calculateFVGScore(gap, impulsePercent, atr, avgVol, [prev2, prev1, curr]);

                        let zone = {
                            id: `fvg-l-${i}`,
                            type: 'FVG',
                            top: curr.low,
                            bottom: prev2.high,
                            time: prev1.time,
                            endTime: null,
                            status: 'ACTIVE',
                            color: 'rgba(168, 85, 247, 0.4)',
                            quality: fvgScore,
                            midPoint: prev2.high + (gap / 2),
                            gapSize: gap,
                            impulsePercent: impulsePercent
                        };

                        for (let j = i + 1; j < c.length; j++) {
                            if (barTouchesZone(c[j], zone.top, zone.bottom)) {
                                zone.status = 'MITIGATED';
                                zone.endTime = c[j].time;
                                break;
                            }
                        }
                        state.zones.push(zone);

                        if (!keepTrades) {
                            const trade = createTrade(i, 'LONG', curr.low, Math.min(c[i - 1].low, c[i - 2].low), curr.time, c);
                            if (trade) localTrades.push(trade);
                        }

                        // OB Bullish asociado
                        let obCandleIdx = -1;
                        for (let k = i - 1; k >= Math.max(0, i - 10); k--) {
                            if (c[k].close < c[k].open) { obCandleIdx = k; break; }
                        }

                        if (obCandleIdx !== -1 && !processedOBs.has(obCandleIdx)) {
                            const obCandle = c[obCandleIdx];
                            const obAtr = atrValues[obCandleIdx] || atr;
                            const obAvgVol = avgVolumes[obCandleIdx] || avgVol;
                            const obScore = calculateOBScore(obCandle, obCandleIdx, true, obAtr, obAvgVol);

                            let ob = {
                                id: `ob-l-${obCandleIdx}`,
                                type: 'OB',
                                top: obCandle.high,
                                bottom: obCandle.low,
                                time: obCandle.time,
                                endTime: null,
                                status: 'ACTIVE',
                                color: 'rgba(234, 179, 8, 0.4)',
                                quality: obScore,
                                volume: obCandle.volume || 0,
                                hasBOS: obScore >= 35,
                                size: obCandle.high - obCandle.low
                            };

                            for (let j = i + 1; j < c.length; j++) {
                                if (barTouchesZone(c[j], ob.top, ob.bottom)) {
                                    ob.status = 'MITIGATED';
                                    ob.endTime = c[j].time;
                                    break;
                                }
                            }
                            state.zones.push(ob);
                            processedOBs.add(obCandleIdx);
                        }
                    }
                }

                // --- FVG Bearish ---
                if (curr.high < prev2.low) {
                    const gap = prev2.low - curr.high;
                    const gapPercent = gap / curr.close;
                    let validFVG = true;

                    if (gap < (curr.close * sens)) validFVG = false;
                    if (gap < atr * 0.2) validFVG = false;

                    const impulse = prev2.close - curr.close;
                    const impulsePercent = Math.abs(impulse / prev2.close);
                    if (impulsePercent < 0.003) validFVG = false;

                    if (curr.volume && prev1.volume && prev2.volume) {
                        const avgVolLocal = (prev1.volume + prev2.volume) / 2;
                        if (curr.volume < avgVolLocal * 0.5) validFVG = false;
                    }

                    if (validFVG) {
                        const fvgScore = calculateFVGScore(gap, impulsePercent, atr, avgVol, [prev2, prev1, curr]);

                        let zone = {
                            id: `fvg-s-${i}`,
                            type: 'FVG',
                            top: prev2.low,
                            bottom: curr.high,
                            time: prev1.time,
                            endTime: null,
                            status: 'ACTIVE',
                            color: 'rgba(168, 85, 247, 0.4)',
                            quality: fvgScore,
                            midPoint: curr.high + (gap / 2),
                            gapSize: gap,
                            impulsePercent: impulsePercent
                        };

                        for (let j = i + 1; j < c.length; j++) {
                            if (barTouchesZone(c[j], zone.top, zone.bottom)) {
                                zone.status = 'MITIGATED';
                                zone.endTime = c[j].time;
                                break;
                            }
                        }
                        state.zones.push(zone);

                        if (!keepTrades) {
                            const trade = createTrade(i, 'SHORT', curr.high, Math.max(c[i - 1].high, c[i - 2].high), curr.time, c);
                            if (trade) localTrades.push(trade);
                        }

                        // OB Bearish asociado
                        let obCandleIdx = -1;
                        for (let k = i - 1; k >= Math.max(0, i - 10); k--) {
                            if (c[k].close > c[k].open) { obCandleIdx = k; break; }
                        }

                        if (obCandleIdx !== -1 && !processedOBs.has(obCandleIdx)) {
                            const obCandle = c[obCandleIdx];
                            const obAtr = atrValues[obCandleIdx] || atr;
                            const obAvgVol = avgVolumes[obCandleIdx] || avgVol;
                            const obScore = calculateOBScore(obCandle, obCandleIdx, false, obAtr, obAvgVol);

                            let ob = {
                                id: `ob-s-${obCandleIdx}`,
                                type: 'OB',
                                top: obCandle.high,
                                bottom: obCandle.low,
                                time: obCandle.time,
                                endTime: null,
                                status: 'ACTIVE',
                                color: 'rgba(234, 179, 8, 0.4)',
                                quality: obScore,
                                volume: obCandle.volume || 0,
                                hasBOS: obScore >= 35,
                                size: obCandle.high - obCandle.low
                            };

                            for (let j = i + 1; j < c.length; j++) {
                                if (barTouchesZone(c[j], ob.top, ob.bottom)) {
                                    ob.status = 'MITIGATED';
                                    ob.endTime = c[j].time;
                                    break;
                                }
                            }
                            state.zones.push(ob);
                            processedOBs.add(obCandleIdx);
                        }
                    }
                }
            }

            state.zones.sort((a, b) => (a.time || 0) - (b.time || 0));
            if (!keepTrades) state.trades = localTrades;
        }

        function updateStratDesc() {
            const strat = document.getElementById('strat-selector').value;
            const desc = document.getElementById('strat-desc');

            if (strat === 'TL_TRAP') {
                desc.innerText = 'TL Trap estándar: Entrada al cierre cuando el precio mitiga el OB sin traspasarlo. RR 2:1.';
            } else if (strat === 'TL_TRAP_AGRO') {
                desc.innerText = 'TL Trap Agresivo: Misma lógica que TL Trap pero con RR 3:1 para mayor beneficio potencial.';
            } else if (strat === 'TL_TRAP_ATR') {
                desc.innerText = 'TL Trap ATR: Orden límite en OB ± ATR. SL en entrada ± ATR*1.1. RR 2:1.';
            } else if (strat === 'TL_TRAP_ATR_AGRO') {
                desc.innerText = 'TL Trap ATR Agro: Mismo concepto ATR pero con RR 3:1.';
            } else if (strat === 'TL_TRAP_ATR_PARTIAL_1') {
                desc.innerText = 'TL Trap ATR Parcial: 50% TP en 3R y 50% en 5R. SL sube a BE al superar 1R.';
            } else if (strat === 'TL_TRAP_ATR_PARTIAL_2') {
                desc.innerText = 'TL Trap ATR Parcial: 50% TP en 2R y 50% en 4R. SL sube a BE al superar 1R.';
            } else if (strat === 'OPTIMIZER') {
                desc.innerText = 'Optimizador TL Trap: compara distintas combinaciones de RR y gestión (BE / parciales) y muestra cuál es más eficiente.';
            } else {
                desc.innerText = 'Estrategia basada en zonas de Oferta/Demanda (OB) y vacíos de liquidez (FVG). Entra en mitigación.';
            }
        }

        // --- ESTRATEGIA TL TRAP (núcleo) + soporte para optimizador ---
        function runLiquidityStrategy(mode = 'auto', options = {}) {
            const collectOnly = !!options.collectOnly;
            const c = state.candles;
            if (!c || c.length === 0) return collectOnly ? { trades: [], brokenLines: [] } : undefined;

            // Si el modo es auto, se mapea desde el selector de la pestaña Op
            if (mode === 'auto') {
                const sel = document.getElementById('trade-strat-select');
                const val = sel ? sel.value : 'TL_TRAP';
                if (val === 'TL_TRAP') mode = 'standard';
                else if (val === 'TL_TRAP_AGRO') mode = 'agro';
                else if (val === 'TL_TRAP_ATR') mode = 'atr';
                else if (val === 'TL_TRAP_ATR_AGRO') mode = 'atr_agro';
                else if (val === 'TL_TRAP_ATR_PARTIAL_1') mode = 'atr_partial_1';
                else if (val === 'TL_TRAP_ATR_PARTIAL_2') mode = 'atr_partial_2';
                else mode = 'standard';
            }

            analyzeSMC(true);
            const allLines = calculateTrendLines(true);

            // Checkbox de análisis de volumen
            const useVolumeAnalysis = document.getElementById('check-volume-analysis')?.checked || false;

            // ATR precalculado
            const atrPeriod = 14;
            let atrValues = new Float64Array(c.length);
            for (let i = atrPeriod; i < c.length; i++) {
                let trSum = 0;
                for (let j = 0; j < atrPeriod; j++) {
                    const idx = i - j;
                    const tr = Math.max(
                        c[idx].high - c[idx].low,
                        Math.abs(c[idx].high - c[idx - 1].close),
                        Math.abs(c[idx].low - c[idx - 1].close)
                    );
                    trSum += tr;
                }
                atrValues[i] = trSum / atrPeriod;
            }

            // Volumen promedio
            let avgVolumes = null;
            if (useVolumeAnalysis) {
                avgVolumes = new Float64Array(c.length);
                const volPeriod = 20;
                for (let i = volPeriod; i < c.length; i++) {
                    let volSum = 0;
                    for (let j = 0; j < volPeriod; j++) {
                        volSum += c[i - j].volume || 0;
                    }
                    avgVolumes[i] = volSum / volPeriod;
                }
            }

            let strategyTrades = [];
            const processedOBs = new Set();

            const brokenLines = allLines.filter(l => l.status === 'BROKEN');

            const bullishOBs = state.zones.filter(z => z.type === 'OB' && z.id.includes('-l-'));
            const bearishOBs = state.zones.filter(z => z.type === 'OB' && z.id.includes('-s-'));
            const bullishFVGs = state.zones.filter(z => z.type === 'FVG' && z.id.includes('-l-'));
            const bearishFVGs = state.zones.filter(z => z.type === 'FVG' && z.id.includes('-s-'));

            const barTouchesZone = (bar, top, bottom) => {
                const zTop = Math.max(top, bottom);
                const zBottom = Math.min(top, bottom);
                return bar.low <= zTop && bar.high >= zBottom;
            };

            const findOBsAtTLTouches = (line, obs, toleranceBars = 5) => {
                if (!line.touchIndices || line.touchIndices.length === 0) return [];
                const matchedOBs = [];
                for (const ob of obs) {
                    const obIdx = parseInt(ob.id.split('-')[2]);
                    if (isNaN(obIdx)) continue;
                    for (const touchIdx of line.touchIndices) {
                        if (Math.abs(obIdx - touchIdx) <= toleranceBars) {
                            matchedOBs.push(ob);
                            break;
                        }
                    }
                }
                return matchedOBs;
            };

            const filterNearbyOBs = (obs, isShortTrap, proximityPct = 0.01) => {
                if (obs.length <= 1) return obs;
                const sorted = [...obs].sort((a, b) => {
                    const midA = (a.top + a.bottom) / 2;
                    const midB = (b.top + b.bottom) / 2;
                    return midA - midB;
                });
                const selected = [];
                let i = 0;
                while (i < sorted.length) {
                    const current = sorted[i];
                    const currentMid = (current.top + current.bottom) / 2;
                    let group = [current];
                    let j = i + 1;
                    while (j < sorted.length) {
                        const nextMid = (sorted[j].top + sorted[j].bottom) / 2;
                        const diff = Math.abs(nextMid - currentMid) / currentMid;
                        if (diff <= proximityPct) {
                            group.push(sorted[j]);
                            j++;
                        } else {
                            break;
                        }
                    }
                    let best = group[0];
                    for (const ob of group) {
                        const obTop = Math.max(ob.top, ob.bottom);
                        const obBottom = Math.min(ob.top, ob.bottom);
                        const bestTop = Math.max(best.top, best.bottom);
                        const bestBottom = Math.min(best.top, best.bottom);
                        if (isShortTrap) {
                            if (obTop > bestTop) best = ob;
                        } else {
                            if (obBottom < bestBottom) best = ob;
                        }
                    }
                    selected.push(best);
                    i = j;
                }
                return selected;
            };

            const analyzeEntryCandle = (bar, avgVol, isShortTrap) => {
                if (!useVolumeAnalysis) return { score: 0 };

                const body = Math.abs(bar.close - bar.open);
                const range = bar.high - bar.low;
                const volume = bar.volume || 0;

                const bodyRatio = range > 0 ? body / range : 0;
                const volRatio = avgVol > 0 ? volume / avgVol : 1;

                const upperWick = bar.high - Math.max(bar.open, bar.close);
                const lowerWick = Math.min(bar.open, bar.close) - bar.low;
                const wickRatio = range > 0 ? (isShortTrap ? upperWick : lowerWick) / range : 0;

                const signals = { absorption: false, rejection: false, highVolume: false, score: 0 };

                if (volRatio > 1.2 && bodyRatio < 0.4) {
                    signals.absorption = true;
                    signals.score += 2;
                }

                if (wickRatio > 0.5) {
                    signals.rejection = true;
                    signals.score += 2;
                }

                if (volRatio > 1.5) {
                    signals.highVolume = true;
                    signals.score += 1;
                }

                if (signals.absorption && signals.rejection) {
                    signals.score += 2;
                }

                return signals;
            };

            const atrMultiplierSL = 1.0;
            const atrMultiplierSL_ATR = 1.1;
            const lookaheadBars = 100;
            const obTouchTolerance = 5;
            const obProximityPct = 0.01;

            let rrMultiplier = 2;
            let isATRMode = false;
            let isPartialMode = false;
            let tp1RR = 0, tp2RR = 0;

            if (mode === 'agro') {
                rrMultiplier = 3;
            } else if (mode === 'atr') {
                isATRMode = true;
                rrMultiplier = 2;
            } else if (mode === 'atr_agro') {
                isATRMode = true;
                rrMultiplier = 3;
            } else if (mode === 'atr_partial_1') {
                isATRMode = true;
                isPartialMode = true;
                tp1RR = 3;
                tp2RR = 5;
            } else if (mode === 'atr_partial_2') {
                isATRMode = true;
                isPartialMode = true;
                tp1RR = 2;
                tp2RR = 4;
            }

            for (const line of brokenLines) {
                const breakIdx = line.breakIndex;
                if (breakIdx == null || breakIdx <= 0 || breakIdx >= c.length) continue;

                const isShortTrap = (line.type === 'DOWN');
                const obs = isShortTrap ? bearishOBs : bullishOBs;
                const fvgs = isShortTrap ? bearishFVGs : bullishFVGs;
                const breakTime = c[breakIdx].time;

                const matchedOBs = findOBsAtTLTouches(line, obs, obTouchTolerance);
                if (matchedOBs.length === 0) continue;

                const validOBs = matchedOBs.filter(ob => {
                    const obIdx = parseInt(ob.id.split('-')[2]);
                    if (obIdx >= breakIdx) return false;
                    if (ob.endTime && ob.endTime < breakTime) return false;
                    return true;
                });

                if (validOBs.length === 0) continue;

                const filteredOBs = filterNearbyOBs(validOBs, isShortTrap, obProximityPct);

                for (const ob of filteredOBs) {
                    const obIdx = parseInt(ob.id.split('-')[2]);
                    if (processedOBs.has(ob.id)) continue;

                    const obTop = Math.max(ob.top, ob.bottom);
                    const obBottom = Math.min(ob.top, ob.bottom);

                    // FVG asociado
                    let associatedFvg = null;
                    for (const fvg of fvgs) {
                        const fvgIdx = parseInt(fvg.id.split('-')[2]);
                        if (isNaN(fvgIdx) || fvgIdx >= breakIdx) continue;

                        const dist = Math.abs(fvgIdx - obIdx);
                        if (dist > 10) continue;

                        if (fvg.endTime && fvg.endTime < breakTime) continue;

                        if (!associatedFvg || dist < Math.abs(parseInt(associatedFvg.id.split('-')[2]) - obIdx)) {
                            associatedFvg = fvg;
                        }
                    }

                    if (!associatedFvg) continue;

                    let entryIdx = -1;
                    let entryPrice = 0;
                    let slPrice = 0;
                    let entrySignals = null;

                    if (isATRMode) {
                        const atrAtBreak = atrValues[breakIdx] || (c[breakIdx].high - c[breakIdx].low);
                        let limitOrderPrice;

                        if (isShortTrap) {
                            limitOrderPrice = obTop + atrAtBreak;
                        } else {
                            limitOrderPrice = obBottom - atrAtBreak;
                        }

                        for (let k = breakIdx + 1; k < Math.min(c.length, breakIdx + lookaheadBars); k++) {
                            const bar = c[k];

                            if ((isShortTrap && bar.high >= limitOrderPrice) || (!isShortTrap && bar.low <= limitOrderPrice)) {
                                entryIdx = k;
                                entryPrice = limitOrderPrice;
                                break;
                            }
                        }

                        if (entryIdx !== -1) {
                            const atrAtEntry = atrValues[entryIdx] || (c[entryIdx].high - c[entryIdx].low);
                            slPrice = isShortTrap ? entryPrice + (atrAtEntry * atrMultiplierSL_ATR) : entryPrice - (atrAtEntry * atrMultiplierSL_ATR);
                            if (useVolumeAnalysis) {
                                entrySignals = analyzeEntryCandle(c[entryIdx], avgVolumes?.[entryIdx] || 1, isShortTrap);
                            }
                        }
                    } else {
                        for (let k = breakIdx + 1; k < Math.min(c.length, breakIdx + lookaheadBars); k++) {
                            if (barTouchesZone(c[k], ob.top, ob.bottom)) {
                                entryIdx = k;
                                break;
                            }
                        }

                        if (entryIdx === -1) continue;

                        const entryBar = c[entryIdx];
                        const validClose = isShortTrap ? entryBar.close <= obTop : entryBar.close >= obBottom;

                        if (!validClose) continue;

                        entryPrice = entryBar.close;
                        const atrAtEntry = atrValues[entryIdx] || (entryBar.high - entryBar.low);
                        slPrice = isShortTrap ? obTop + (atrAtEntry * atrMultiplierSL) : obBottom - (atrAtEntry * atrMultiplierSL);

                        if (useVolumeAnalysis) {
                            entrySignals = analyzeEntryCandle(entryBar, avgVolumes?.[entryIdx] || 1, isShortTrap);
                        }
                    }

                    if (entryIdx === -1) continue;

                    if (useVolumeAnalysis && entrySignals && entrySignals.score < 2) {
                        continue;
                    }

                    processedOBs.add(ob.id);

                    const entryBar = c[entryIdx];
                    const risk = Math.abs(entryPrice - slPrice);
                    if (!isFinite(risk) || risk <= 0) continue;

                    const tpPrice = isShortTrap ? entryPrice - rrMultiplier * risk : entryPrice + rrMultiplier * risk;
                    const setupScore = (line.duration || 0) + (entrySignals ? entrySignals.score * 10 : 0);

                    let outcome = 'OPEN';
                    let exitTime = null;
                    let pnlR = 0;
                    let tpPriceForDisplay = tpPrice;
                    let modeLabel = 'TL Trap';
                    let tradeDesc = '';

                    if (isPartialMode) {
                        const tp1Price = isShortTrap ? entryPrice - tp1RR * risk : entryPrice + tp1RR * risk;
                        const tp2Price = isShortTrap ? entryPrice - tp2RR * risk : entryPrice + tp2RR * risk;
                        const bePrice = entryPrice;

                        let currentSL = slPrice;
                        let tp1Hit = false;
                        let movedToBE = false;
                        let partialPnL = 0;

                        for (let k = entryIdx + 1; k < c.length; k++) {
                            const bar = c[k];
                            const maxFavorable = isShortTrap ? entryPrice - bar.low : bar.high - entryPrice;
                            const currentRR = maxFavorable / risk;

                            if (!movedToBE && currentRR >= 1) {
                                currentSL = bePrice;
                                movedToBE = true;
                            }

                            const hitSL = isShortTrap ? bar.high >= currentSL : bar.low <= currentSL;
                            const hitTP1 = isShortTrap ? bar.low <= tp1Price : bar.high >= tp1Price;
                            const hitTP2 = isShortTrap ? bar.low <= tp2Price : bar.high >= tp2Price;

                            if (!tp1Hit && hitTP1) {
                                tp1Hit = true;
                                partialPnL += 0.5 * tp1RR;
                                currentSL = bePrice;
                            }

                            if (tp1Hit && hitTP2) {
                                partialPnL += 0.5 * tp2RR;
                                outcome = 'WIN';
                                exitTime = bar.time;
                                pnlR = partialPnL;
                                break;
                            }

                            if (hitSL) {
                                if (tp1Hit) {
                                    pnlR = partialPnL;
                                    outcome = 'WIN';
                                } else if (movedToBE) {
                                    pnlR = 0;
                                    outcome = 'BE';
                                } else {
                                    pnlR = -1;
                                    outcome = 'LOSS';
                                }
                                exitTime = bar.time;
                                break;
                            }
                        }

                        tpPriceForDisplay = tp2Price;
                        modeLabel = 'TL Parcial';
                        tradeDesc = `${modeLabel} [${tp1RR}:1 + ${tp2RR}:1]`;

                    } else {
                        for (let k = entryIdx + 1; k < c.length; k++) {
                            const bar = c[k];
                            const hitSL = isShortTrap ? bar.high >= slPrice : bar.low <= slPrice;
                            const hitTP = isShortTrap ? bar.low <= tpPrice : bar.high >= tpPrice;

                            if (hitSL && hitTP) { outcome = 'LOSS'; exitTime = bar.time; pnlR = -1; break; }
                            else if (hitSL) { outcome = 'LOSS'; exitTime = bar.time; pnlR = -1; break; }
                            else if (hitTP) { outcome = 'WIN'; exitTime = bar.time; pnlR = rrMultiplier; break; }
                        }

                        if (mode === 'agro') modeLabel = 'TL Agro';
                        else if (mode === 'atr') modeLabel = 'TL ATR';
                        else if (mode === 'atr_agro') modeLabel = 'TL ATR Agro';

                        tradeDesc = `${modeLabel} [${rrMultiplier}:1]`;
                    }

                    let signalTags = '';
                    if (entrySignals) {
                        if (entrySignals.absorption) signalTags += '🔄';
                        if (entrySignals.rejection) signalTags += '📍';
                        if (entrySignals.highVolume) signalTags += '📊';
                    }

                    strategyTrades.push({
                        id: `trap-${mode}-${line.type}-${ob.id}`,
                        time: entryBar.time,
                        type: isShortTrap ? 'SHORT' : 'LONG',
                        entry: entryPrice,
                        sl: slPrice,
                        tp: tpPriceForDisplay,
                        outcome: outcome,
                        status: outcome === 'BE' ? 'OPEN' : outcome,
                        pnl: pnlR,
                        pnlPercent: pnlR,
                        desc: `${tradeDesc} ${signalTags}`.trim(),
                        entryTime: entryBar.time,
                        exitTime: exitTime,
                        setupScore: setupScore,
                        entrySignals: entrySignals,
                        savedOB: JSON.parse(JSON.stringify(ob)),
                        savedFVG: JSON.parse(JSON.stringify(associatedFvg)),
                        savedLine: JSON.parse(JSON.stringify(line))
                    });
                }
            }

            // Ordenar por tiempo (más reciente primero)
            strategyTrades.sort((a, b) => b.time - a.time);

            if (collectOnly) {
                return { trades: strategyTrades, brokenLines };
            }

            state.trades = strategyTrades;
            renderStratResults(state.trades);
            trendPrimitive.setData(brokenLines.slice(-100));
            return { trades: strategyTrades, brokenLines };
        }

        function runSelectedStrategy() {
            const strat = document.getElementById('strat-selector').value;
            const list = document.getElementById('list-strat-trades');

            if (list) {
                list.innerHTML = '<div class="p-4 text-center text-xs text-slate-600 italic"><div class="spinner mx-auto mb-2"></div>Ejecutando backtest...</div>';
            }

            // nuevo backtest => desbloquea PnL live
            state.pnlLocked = false;

            setTimeout(() => {
                if (strat === 'TL_TRAP') {
                    runLiquidityStrategy('standard');
                } else if (strat === 'TL_TRAP_AGRO') {
                    runLiquidityStrategy('agro');
                } else if (strat === 'TL_TRAP_ATR') {
                    runLiquidityStrategy('atr');
                } else if (strat === 'TL_TRAP_ATR_AGRO') {
                    runLiquidityStrategy('atr_agro');
                } else if (strat === 'TL_TRAP_ATR_PARTIAL_1') {
                    runLiquidityStrategy('atr_partial_1');
                } else if (strat === 'TL_TRAP_ATR_PARTIAL_2') {
                    runLiquidityStrategy('atr_partial_2');
                } else if (strat === 'OPTIMIZER') {
                    runOptimizer();
                } else {
                    analyzeSMC();
                    const smcTrades = [...state.trades].sort((a, b) => {
                        const tA = a.time || a.signalTime || a.entryTime || 0;
                        const tB = b.time || b.signalTime || b.entryTime || 0;
                        return tB - tA;
                    });
                    renderStratResults(smcTrades);
                    state.trades = smcTrades;
                }

                updatePnLMetrics();
            }, 80);
        }

        window.runSelectedStrategy = runSelectedStrategy;
        window.updateStratDesc = updateStratDesc;

        function enterReplay() {
            state.isReplayMode = true;

            const btn = document.getElementById('btn-back-live');
            if (btn) {
                btn.classList.remove('hidden');
                btn.classList.add('flex');
            }

            clearLines();
            if (candleSeries) {
                candleSeries.setMarkers([]);
            }
        }

        function zoomRange(from, to) {
            if (!chart || !from || !to) return;

            if (from > to) {
                const tmp = from;
                from = to;
                to = tmp;
            }

            const span = to - from;
            const pad = Math.max(span * 0.25, 60 * 15);

            chart.timeScale().setVisibleRange({
                from: from - pad,
                to: to + pad
            });
        }

        window.replayTrade = (tradeId) => {
            const t = state.trades.find(tr => tr.id === tradeId);
            if (!t) return;

            enterReplay();

            boxPrimitive.setData([]);
            trendPrimitive.setData([]);

            clearLines();
            createLine(t.entry, '#2962ff', 'ENTRY');
            createLine(t.tp, '#089981', 'TP');
            createLine(t.sl, '#f23645', 'SL');

            const markers = [];

            if (t.signalTime) {
                markers.push({
                    time: t.signalTime,
                    position: t.type === 'LONG' ? 'belowBar' : 'aboveBar',
                    color: '#3b82f6',
                    shape: t.type === 'LONG' ? 'arrowUp' : 'arrowDown',
                    text: 'IDEA'
                });
            }

            if (t.entryTime) {
                markers.push({
                    time: t.entryTime,
                    position: t.type === 'LONG' ? 'belowBar' : 'aboveBar',
                    color: '#2962ff',
                    shape: t.type === 'LONG' ? 'arrowUp' : 'arrowDown',
                    text: 'ENTRY'
                });
            }

            if (t.exitTime && (t.status === 'WIN' || t.status === 'LOSS')) {
                markers.push({
                    time: t.exitTime,
                    position: t.type === 'LONG' ? 'aboveBar' : 'belowBar',
                    color: t.status === 'WIN' ? '#089981' : '#f23645',
                    shape: 'circle',
                    text: t.status
                });
            }

            candleSeries.setMarkers(markers);

            const from = t.entryTime || t.signalTime || state.candles[0]?.time;
            const to = t.exitTime || (from ? from + 3600 * 2 : state.candles[state.candles.length - 1]?.time);

            if (from && to) {
                zoomRange(from, to);
            }
        };

        function renderVisuals() {
            const limit = parseInt(document.getElementById('zone-limit').value);
            const showFVG = document.getElementById('toggle-fvg').checked;
            const showOB = document.getElementById('toggle-ob').checked;

            boxPrimitive.setData([]);
            trendPrimitive.setData([]);
            regPrimitive.setData(null);

            if (state.activeMode !== 'strat') {
                candleSeries.setMarkers([]);
            }
            clearLines();

            if (state.activeMode === 'zones') {
                let list = state.activeZoneTab === 'active'
                    ? state.zones.filter(z => z.status === 'ACTIVE').slice(-limit)
                    : state.zones.filter(z => z.status === 'MITIGATED').slice(-limit);
                list = list.filter(z => (z.type === 'FVG' && showFVG) || (z.type === 'OB' && showOB));
                boxPrimitive.setData(list);
            }
            else if (state.activeMode === 'trades') {
                let markers = [];
                state.trades.slice(-50).forEach(t => {
                    if (state.activeTradeTab === 'ideas' && t.status === 'PENDING') {
                        markers.push({
                            time: t.signalTime,
                            position: 'aboveBar',
                            color: '#3b82f6',
                            shape: 'arrowDown',
                            text: 'IDEA'
                        });
                    }
                    if (state.activeTradeTab === 'active' && t.status === 'OPEN') {
                        markers.push({
                            time: t.entryTime,
                            position: 'belowBar',
                            color: '#fbbf24',
                            shape: 'arrowUp',
                            text: 'LIVE'
                        });
                    }
                    if (state.activeTradeTab === 'history' && (t.status === 'WIN' || t.status === 'LOSS')) {
                        markers.push({
                            time: t.exitTime,
                            position: 'aboveBar',
                            color: t.status === 'WIN' ? '#089981' : '#f23645',
                            shape: 'circle',
                            text: t.status
                        });
                    }
                });
                candleSeries.setMarkers(markers);
            }
            else if (state.activeMode === 'lines') {
                trendPrimitive.setData(state.lines);
            }
            else if (state.activeMode === 'reglin') {
                regPrimitive.setData(state.channel);
            }
        }

        function updateUI() {
            const zoneCountEl = document.getElementById('zone-count-display');
            if (zoneCountEl) zoneCountEl.innerText = document.getElementById('zone-limit').value;

            const activeZones = state.zones.filter(z => z.status === 'ACTIVE');
            const historyZones = state.zones.filter(z => z.status === 'MITIGATED');

            renderList('list-zones-active', activeZones.slice(-20).reverse(), renderZoneCard);
            renderList('list-zones-history', historyZones.slice(-20).reverse(), renderZoneCard);

            renderList('list-trades-ideas', state.trades.filter(t => t.status === 'PENDING').reverse(), renderTradeCard);
            renderList('list-trades-active', state.trades.filter(t => t.status === 'OPEN').reverse(), renderTradeCard);
            renderList('list-trades-history', state.trades.filter(t => t.status === 'WIN' || t.status === 'LOSS').reverse().slice(0, 20), renderTradeCard);
        }

        function addToLog(msg) {
            document.getElementById('system-log').insertAdjacentHTML('afterbegin', `<div>> ${msg}</div>`);
        }

        // --- OPTIMIZADOR DE TL TRAP ---
        function runOptimizer() {
            const container = document.getElementById('list-strat-trades');
            if (!container) return;

            container.innerHTML = `
                <div class="p-4 text-center text-xs text-slate-600 italic">
                    <div class="spinner mx-auto mb-2"></div>
                    Evaluando combinaciones TL Trap...
                </div>
            `;

            setTimeout(() => {
                const configs = [
                    { key: 'standard', label: 'TL Trap 2R', rr: '2R', be: 'N/A' },
                    { key: 'agro', label: 'TL Trap 3R', rr: '3R', be: 'N/A' },
                    { key: 'atr', label: 'TL ATR 2R', rr: '2R', be: 'N/A' },
                    { key: 'atr_agro', label: 'TL ATR 3R', rr: '3R', be: 'N/A' },
                    { key: 'atr_partial_1', label: 'TL Parcial 3R + 5R', rr: '3R + 5R', be: '1R' },
                    { key: 'atr_partial_2', label: 'TL Parcial 2R + 4R', rr: '2R + 4R', be: '1R' }
                ];

                const results = [];
                for (const cfg of configs) {
                    const res = runLiquidityStrategy(cfg.key, { collectOnly: true });
                    const trades = res.trades || [];
                    const wins = trades.filter(t => t.status === 'WIN').length;
                    const losses = trades.filter(t => t.status === 'LOSS').length;
                    const total = trades.length;
                    const totalPnL = trades.reduce((s, t) => s + (t.pnl || 0), 0);
                    const wr = (wins + losses) > 0 ? (wins / (wins + losses)) * 100 : 0;
                    const grossProfit = trades.filter(t => t.pnl > 0).reduce((s, t) => s + t.pnl, 0);
                    const grossLoss = trades.filter(t => t.pnl < 0).reduce((s, t) => s + Math.abs(t.pnl), 0);
                    const pf = grossLoss > 0 ? grossProfit / grossLoss : (grossProfit > 0 ? 999 : 0);

                    results.push({
                        ...cfg,
                        trades,
                        total,
                        wins,
                        losses,
                        winRate: wr,
                        totalPnL,
                        profitFactor: pf
                    });
                }

                state.optimizerResults = results;

                let best = null;
                for (const r of results) {
                    if (!best || r.totalPnL > best.totalPnL) best = r;
                }
                const bestKey = best ? best.key : null;

                let html = `
                    <div class="bg-[#1a1f2e] p-3 rounded border border-border mb-3">
                        <div class="text-[10px] text-slate-400 mb-2">
                            Optimizador TL Trap (RR / Parciales / BE)
                        </div>
                        <div class="grid grid-cols-3 gap-2 text-center">
                            <div>
                                <div class="text-[9px] text-slate-500 uppercase">Configs</div>
                                <div class="text-sm font-bold text-white">${results.length}</div>
                            </div>
                            <div>
                                <div class="text-[9px] text-slate-500 uppercase">Mejor PnL</div>
                                <div class="text-sm font-bold ${best && best.totalPnL >= 0 ? 'text-bull' : 'text-bear'}">
                                    ${best ? (best.totalPnL >= 0 ? '+' : '') + best.totalPnL.toFixed(1) + 'R' : '---'}
                                </div>
                            </div>
                            <div>
                                <div class="text-[9px] text-slate-500 uppercase">Mejor Win%</div>
                                <div class="text-sm font-bold ${best && best.winRate >= 50 ? 'text-bull' : 'text-bear'}">
                                    ${best ? best.winRate.toFixed(1) + '%' : '---'}
                                </div>
                            </div>
                        </div>
                        <div class="text-[9px] text-slate-500 mt-2">
                            Haz click en una fila para aplicar esa configuración al PnL.
                        </div>
                    </div>
                `;

                html += '<div class="space-y-1">';
                for (const r of results) {
                    const pnlClass = r.totalPnL >= 0 ? 'text-bull' : 'text-bear';
                    const wrClass = r.winRate >= 50 ? 'text-bull' : 'text-bear';
                    const pfClass = r.profitFactor >= 1.2 ? 'text-bull' : 'text-bear';
                    const isBest = r.key === bestKey;

                    html += `
                        <div class="strat-card bg-[#161b25] p-2 rounded border ${isBest ? 'border-bull' : 'border-border/50'} hover:border-accent/60 cursor-pointer"
                             data-opt-mode="${r.key}"
                             onclick="applyOptimizerResult('${r.key}')">
                            <div class="flex justify-between items-center mb-1">
                                <div class="flex items-center gap-2">
                                    <span class="text-[10px] text-strat font-bold">${r.label}</span>
                                    ${isBest ? '<span class="text-[9px] px-1.5 py-0.5 rounded bg-bull/10 text-bull border border-bull/40">BEST</span>' : ''}
                                </div>
                                <span class="text-[10px] font-mono ${pnlClass}">
                                    ${r.totalPnL >= 0 ? '+' : ''}${r.totalPnL.toFixed(1)}R
                                </span>
                            </div>
                            <div class="grid grid-cols-5 gap-1 text-[9px] text-slate-400 mt-1">
                                <div>
                                    <div>RR</div>
                                    <div class="text-white/80">${r.rr}</div>
                                </div>
                                <div>
                                    <div>BE@</div>
                                    <div class="text-white/80">${r.be}</div>
                                </div>
                                <div>
                                    <div>Win%</div>
                                    <div class="${wrClass} font-mono">${r.winRate.toFixed(1)}%</div>
                                </div>
                                <div>
                                    <div>PF</div>
                                    <div class="${pfClass} font-mono">${r.profitFactor.toFixed(2)}</div>
                                </div>
                                <div>
                                    <div>Trades</div>
                                    <div class="text-white/80 font-mono">${r.total}</div>
                                </div>
                            </div>
                        </div>
                    `;
                }
                html += '</div>';

                container.innerHTML = html;
            }, 60);
        }

        function applyOptimizerResult(modeKey) {
            if (!state.optimizerResults) return;
            const cfg = state.optimizerResults.find(r => r.key === modeKey);
            if (!cfg) return;

            // fijar PnL en esta configuración
            state.pnlLocked = true;
            state.trades = cfg.trades.map(t => ({ ...t }));
            updatePnLMetrics();

            // resaltar selección
            document.querySelectorAll('#list-strat-trades .strat-card').forEach(el => {
                el.classList.remove('border-white', 'ring-1', 'ring-accent');
            });
            const selected = document.querySelector(`#list-strat-trades .strat-card[data-opt-mode="${modeKey}"]`);
            if (selected) {
                selected.classList.add('border-white', 'ring-1', 'ring-accent');
            }

            // mostrar pestaña PnL
            switchMainTab('pnl');
        }
        window.applyOptimizerResult = applyOptimizerResult;

        // Asegurar exports globales
        window.enterReplay = enterReplay;
        window.zoomRange = zoomRange;
        window.renderVisuals = renderVisuals;
        window.updateUI = updateUI;
        window.updatePnLMetrics = updatePnLMetrics;

        window.setTF = (tf) => {
            APP.interval = tf;
            document.querySelectorAll('.tf-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(`btn-tf-${tf.toLowerCase()}`).classList.add('active');
            document.getElementById('header-tf').innerText = tf;
            runFullLoadPipeline();
        };

        window.manualRefresh = () => runFullLoadPipeline();

        window.updateVisuals = renderVisuals;

        window.goToZone = (zoneId) => {
            const z = state.zones.find(zone => zone.id === zoneId);
            if (z) {
                enterReplay();
                boxPrimitive.setData([z]);
                const duration = z.endTime ? (z.endTime - z.time) : 3600;
                const pad = Math.max(duration * 2, 7200);
                chart.timeScale().setVisibleRange({ from: z.time - pad / 2, to: (z.endTime || z.time) + pad / 2 });
            }
        };

        window.switchMainTab = (tab) => {
            state.activeMode = tab;
            ['zones', 'trades', 'lines', 'reglin', 'strat', 'log', 'pnl'].forEach(id => {
                const el = document.getElementById(`view-${id}`);
                const btn = document.getElementById(`mtab-${id}`);
                if (el) el.style.display = (id === tab) ? 'flex' : 'none';
                if (btn) btn.classList.toggle('active', id === tab);
            });
            document.getElementById('mode-indicator').innerText = `Modo: ${tab}`;

            if (tab === 'pnl') {
                updatePnLMetrics();
                if (pnlChart) pnlChart.timeScale().fitContent();
            }
            if (tab === 'lines') {
                calculateTrendLines();
                calculateHurst();
            }
            if (tab === 'reglin') {
                calculateRegLin();
            }
            if (tab === 'strat') {
                if (typeof addOptimizerToSelector === 'function') {
                    addOptimizerToSelector();
                }
            } else if (tab === 'trades') {
                updateTradeStrategy();
            } else {
                renderVisuals();
            }
        };

        window.switchZoneSubTab = (tab) => {
            state.activeZoneTab = tab;
            document.getElementById('list-zones-active').style.display = tab === 'active' ? 'block' : 'none';
            document.getElementById('list-zones-history').style.display = tab === 'history' ? 'block' : 'none';
            document.getElementById('ztab-active').classList.toggle('active', tab === 'active');
            document.getElementById('ztab-history').classList.toggle('active', tab === 'history');
            renderVisuals();
        };

        window.switchTradeSubTab = (tab) => {
            state.activeTradeTab = tab;
            ['ideas', 'active', 'history'].forEach(t => {
                document.getElementById(`list-trades-${t}`).style.display = (t === tab) ? 'block' : 'none';
                document.getElementById(`ttab-${t}`).classList.toggle('active', t === tab);
            });
            renderVisuals();
        };

        function renderStratResults(trades) {
            const container = document.getElementById('list-strat-trades');
            if (!container) return;

            if (!trades || trades.length === 0) {
                container.innerHTML = '<div class="p-4 text-center text-xs text-slate-600 italic">Sin operaciones encontradas.</div>';
                return;
            }

            const wins = trades.filter(t => t.status === 'WIN').length;
            const losses = trades.filter(t => t.status === 'LOSS').length;
            const opens = trades.filter(t => t.status === 'OPEN').length;
            const totalPnL = trades.reduce((sum, t) => sum + (t.pnl || 0), 0);
            const winRate = (wins + losses) > 0 ? ((wins / (wins + losses)) * 100).toFixed(1) : '0.0';

            let html = `
                <div class="bg-[#1a1f2e] p-3 rounded border border-border mb-3">
                    <div class="grid grid-cols-4 gap-2 text-center">
                        <div>
                            <div class="text-[9px] text-slate-500 uppercase">Total</div>
                            <div class="text-sm font-bold text-white">${trades.length}</div>
                        </div>
                        <div>
                            <div class="text-[9px] text-slate-500 uppercase">Win%</div>
                            <div class="text-sm font-bold ${parseFloat(winRate) >= 50 ? 'text-bull' : 'text-bear'}">${winRate}%</div>
                        </div>
                        <div>
                            <div class="text-[9px] text-slate-500 uppercase">W/L</div>
                            <div class="text-sm font-bold"><span class="text-bull">${wins}</span>/<span class="text-bear">${losses}</span></div>
                        </div>
                        <div>
                            <div class="text-[9px] text-slate-500 uppercase">PnL (R)</div>
                            <div class="text-sm font-bold ${totalPnL >= 0 ? 'text-bull' : 'text-bear'}">${totalPnL >= 0 ? '+' : ''}${totalPnL.toFixed(1)}R</div>
                        </div>
                    </div>
                    ${opens > 0 ? `<div class="text-[9px] text-center text-ob mt-2">${opens} operación(es) abierta(s)</div>` : ''}
                </div>
            `;

            html += '<div class="space-y-1">';
            for (const t of trades) {
                const typeColor = t.type === 'LONG' ? 'text-bull' : 'text-bear';
                const statusColor = t.status === 'WIN' ? 'text-bull' : t.status === 'LOSS' ? 'text-bear' : 'text-ob';
                const pnlColor = t.pnl > 0 ? 'text-bull' : t.pnl < 0 ? 'text-bear' : 'text-slate-500';
                const timeStr = t.time ? new Date(t.time * 1000).toLocaleString() : '---';

                html += `
                    <div id="strat-card-${t.id}" class="strat-card bg-[#161b25] p-2 rounded border border-border/50 hover:border-accent/50 cursor-pointer" onclick="replayStratTrade('${t.id}')">
                        <div class="flex justify-between items-center mb-1">
                            <div class="flex items-center gap-2">
                                <span class="${typeColor} font-bold text-[10px]">${t.type}</span>
                                <span class="text-[9px] text-slate-500">${t.desc || ''}</span>
                            </div>
                            <span class="${statusColor} text-[10px] font-bold">${t.status}</span>
                        </div>
                        <div class="flex justify-between text-[10px] font-mono">
                            <span class="text-slate-400">E: $${t.entry.toFixed(0)}</span>
                            <span class="${pnlColor}">${t.pnl >= 0 ? '+' : ''}${t.pnl.toFixed(1)}R</span>
                        </div>
                        <div class="text-[9px] text-slate-600 mt-1">${timeStr}</div>
                    </div>
                `;
            }
            html += '</div>';
            container.innerHTML = html;
        }

        window.replayStratTrade = function (tradeId) {
            const t = state.trades.find(tr => tr.id === tradeId);
            if (!t) return;

            enterReplay();

            document.querySelectorAll('.strat-card').forEach(el => {
                el.classList.remove('border-white', 'border-2');
                el.classList.add('border-border/50');
            });
            const activeCard = document.getElementById(`strat-card-${tradeId}`);
            if (activeCard) {
                activeCard.classList.remove('border-border/50');
                activeCard.classList.add('border-white', 'border-2');
                activeCard.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }

            const boxes = [];
            if (t.savedOB) boxes.push(t.savedOB);
            if (t.savedFVG) boxes.push(t.savedFVG);
            boxPrimitive.setData(boxes);
            if (t.savedLine) trendPrimitive.setData([t.savedLine]);
            clearLines();
            createLine(t.entry, '#2962ff', 'ENTRY');
            createLine(t.tp, '#089981', 'TP');
            createLine(t.sl, '#f23645', 'SL');
            const markers = [];
            if (t.entryTime) {
                markers.push({
                    time: t.entryTime,
                    position: t.type === 'LONG' ? 'belowBar' : 'aboveBar',
                    color: '#2962ff',
                    shape: t.type === 'LONG' ? 'arrowUp' : 'arrowDown',
                    text: 'ENTRY'
                });
            }
            if (t.exitTime && (t.status === 'WIN' || t.status === 'LOSS')) {
                markers.push({
                    time: t.exitTime,
                    position: t.type === 'LONG' ? 'aboveBar' : 'belowBar',
                    color: t.status === 'WIN' ? '#089981' : '#f23645',
                    shape: 'circle',
                    text: t.status
                });
            }
            candleSeries.setMarkers(markers);
            const lineStart = t.savedLine?.t1 || t.entryTime;
            const from = Math.min(lineStart || t.entryTime, t.entryTime) - 3600;
            const to = t.exitTime || t.entryTime + 7200;
            zoomRange(from, to);
        };

        window.exitReplay = function () {
            state.isReplayMode = false;

            const btn = document.getElementById('btn-back-live');
            if (btn) {
                btn.classList.add('hidden');
                btn.classList.remove('flex');
            }

            clearLines();
            candleSeries.setMarkers([]);

            document.querySelectorAll('.strat-card').forEach(el => {
                el.classList.remove('border-white', 'border-2');
                el.classList.add('border-border/50');
            });

            renderVisuals();

            if (state.candles.length > 0) {
                chart.timeScale().scrollToRealTime();
            }
        };

        // Pestaña Op: cambiar estrategia para ver sus ideas
        window.updateTradeStrategy = function () {
            const activeEl = document.getElementById('list-trades-active');
            if (activeEl) {
                activeEl.innerHTML = '<div class="p-4 text-center text-xs text-slate-600 italic">Cargando...</div>';
            }
            const strat = document.getElementById('trade-strat-select').value;

            if (strat === 'SMC') {
                analyzeSMC();
            } else if (strat === 'TL_TRAP') {
                runLiquidityStrategy('standard');
            } else if (strat === 'TL_TRAP_AGRO') {
                runLiquidityStrategy('agro');
            } else if (strat === 'TL_TRAP_ATR') {
                runLiquidityStrategy('atr');
            } else if (strat === 'TL_TRAP_ATR_AGRO') {
                runLiquidityStrategy('atr_agro');
            } else if (strat === 'TL_TRAP_ATR_PARTIAL_1') {
                runLiquidityStrategy('atr_partial_1');
            } else if (strat === 'TL_TRAP_ATR_PARTIAL_2') {
                runLiquidityStrategy('atr_partial_2');
            }

            renderVisuals();
            updateUI();
        };

        window.addOptimizerToSelector = function () {
            const selector = document.getElementById('strat-selector');
            if (selector && !selector.querySelector('option[value="OPTIMIZER"]')) {
                const option = document.createElement('option');
                option.value = 'OPTIMIZER';
                option.textContent = '🔬 Optimizador Parcial (TP/SL)';
                selector.appendChild(option);
            }
        };

        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(window.addOptimizerToSelector, 500);
        });

    </script>
</body>

</html>